<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Windosw内核理论基础</title>
    <link href="/2024/04/02/Windows%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/04/02/Windows%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Windosw内核理论基础"><a href="#Windosw内核理论基础" class="headerlink" title="Windosw内核理论基础"></a>Windosw内核理论基础</h1><h2 id="Windows体系结构"><a href="#Windows体系结构" class="headerlink" title="Windows体系结构"></a>Windows体系结构</h2><h3 id="CPU权限级别"><a href="#CPU权限级别" class="headerlink" title="CPU权限级别"></a>CPU权限级别</h3><p><strong>系统内核层</strong>，又称<strong>零环</strong>（Ring0，简称R0；与此对应的是<strong>3环</strong>，R3，应用层）；实际上是CPU的4个级别，CPU在设计时将CPU的运行级别从内到外分为4个层级R0-R3，R0权限最高依次降低（实际上，现在只区分R0和R3，并没有使用R1和R2）。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401021844608.png" alt="image-20240102184406550"></p><p>分级的<strong>目的</strong>是为了<strong>保护系统的稳定性和安全性</strong>。通过限制某些操作只能在高权限级别下执行，操作系统可以防止用户级应用程序意外或恶意地修改关键系统资源，进而导致系统崩溃或安全漏洞。</p><p>Windows 体系结构简图：<br><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312261638491.png" alt="image-20231226163845412"></p><p>从上图可以看到，Windows使用双模式来保护操作系统本身，用户模式对应的就是R3，内核模式即R0。在这种架构下，应用程序的代码<strong>只能</strong>运行在用户模式下，每当它需要使用到系统内核或内核的扩展模块（内核驱动程序）所提供的服务时，应用程序通过<strong>硬件指令</strong>从用户模式切换到内核模式中；当系统内核完成了所请求的服务以后，控制权又回到用户模式代码。</p><h3 id="内存空间布局"><a href="#内存空间布局" class="headerlink" title="内存空间布局"></a>内存空间布局</h3><p>Windows中，用户代码和内核代码有各自的运行环境，并且它们可以访问的内存空间也不同。</p><p>以x64为例，在4G的虚拟内存空间中，WIndows系统的内存分为<strong>内核空间</strong>和<strong>应用空间</strong>，每部分各占2GB。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312261556935.png" alt="image-20231213212456137"></p><p>其中用户空间占用低地址（00000000 ~ 7FFFEFFF），内核空间占用高地址(7FFF000 ~ FFFFFFFF)；若是开启了大地址空间模式的程序（LARGE_ADDRESS_AWARE），则内存空间布局会变成3GB 的用户空间，和 1GB 的内核空间。</p><h3 id="Windows内核结构"><a href="#Windows内核结构" class="headerlink" title="Windows内核结构"></a>Windows内核结构</h3><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401021754745.png" alt="image-20240102175441676"></p><p>如图，Windows内核中主要可以分成三层：<strong>硬件抽象层</strong>（HAL），<strong>内核层</strong>（也称微内核micro-kernel），<strong>执行体层</strong>。</p><p>内核层实现操作系统的基本机制，而所有的策略决定则留给执行体。执行体中的对象绝大多数封装了一个或者多个内核对象，并且通过某种方式（比如对象句柄）暴露给应用程序。</p><p>Windows内核为用户模式提供了一组<strong>系统服务</strong>，供应用程序使用内核中的功能。应用程序通常并不直接调用这些系统服务，而是通过一组系统DLL，最终通过<strong>ntdll.dll</strong>切换到内核模式下的执行体API函数中，以调用内核中的系统服务。</p><p><strong>Ntdll.dll是链接用户模式代码和内核模式系统服务的桥梁。</strong>对于内核提供的每一个系统服务，该DLL都提供一个相应的<strong>存根函数</strong>，这些存根函数的名称以“<strong>Nt</strong>”作为前缀，例如<code>NtCreateProcess</code>、<code>NtOpenFile</code>等。另外ntdll.dll还提供了许多系统级的支持函数，比如映像加载器函数（以“<strong>Ldr</strong>”为前缀）、系统时间函数（以“<strong>Etw</strong>”为前缀），以及一般的运行支持函数（以“<strong>Rtl</strong>”为前缀）和字符串支持函数等。</p><p>执行体API函数接收的参数来自于各种应用程序，因此为了保证系统的安全以及抵抗来自用户模式的恶意攻击，所有的执行体API都必须保证参数的<strong>有效性</strong>。通常执行体系统服务函数会在其开始处，对所接收的参数逐一探查它们的可访问性。例如如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PreviousMode = <span class="hljs-built_in">KeGetPreviousMode</span>();<br><span class="hljs-keyword">if</span> (PreviousMode != kernelMode)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-built_in">ProbeForWrite</span>(InputInformation,InputInformationLength,<span class="hljs-built_in">sizeof</span>(ULONG));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ARGUMENT_PRESENT</span>(ReturnLength))&#123;<br>            <span class="hljs-built_in">ProbeForWriteUlong</span>(ReturnLength);<br>        &#125; <span class="hljs-built_in">except</span>(EXCEPTION_EXECUTE_HANDLER)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetExceptionCode</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：</p><ul><li>调用 <code>KeGetPreviousMode</code> 函数来获取当前的执行模式（内核模式or用户模式）</li><li>用 <code>if</code>判断是否是内核模式（kernelMode）</li><li>使用了一个<code>try&#123;...&#125;except()&#123;...&#125;</code> 异常处理，try中包含一些堆内存的探测（Probe）操作</li><li><code>ProbeForWirte</code>是一个检查内存可写性的函数，用于检查<code>InputInformation</code>指向的内存区域是否可以安全写入数据，第二三个参数分别是数据的长度和数据的大小。</li><li>接着检查是否传递了 <code>ReturnLength</code>参数，如果传递了就进一步检查内存可写性</li><li>except 如果触发了异常，用<code>GetExceptionCode</code>获取错误码</li></ul><p><strong>Windows内核中的关键组件</strong>：</p><h4 id="硬件抽象层（HAL）"><a href="#硬件抽象层（HAL）" class="headerlink" title="硬件抽象层（HAL）"></a>硬件抽象层（HAL）</h4><p><strong>硬件抽象层（Hardware Abstraction Layer，HAL）</strong>，这一层把所有与硬件相关联的代码逻辑隔离到一个专门的模块中，为操作系统的上层提供一个<strong>抽象</strong>的、一致的硬件资源模型。这使得上层的模块无须考虑硬件的差异，它们通过HAL而不是直接访问硬件。</p><p>在Windows中，<strong>HAL是一个独立的动态链接库</strong>。HAL提供了一些例程供其他内核模块或设备驱动程序调用，这使得一个驱动程序可以支持同样的设备在各种硬件平台上运行。HAL不仅涵盖了处理器的体系结构，也涉及了中断控制器、单处理器或多处理器等硬件条件。</p><h4 id="内核层"><a href="#内核层" class="headerlink" title="内核层"></a>内核层</h4><p>这是大内核中的小内核，也称<strong>微内核</strong>。它是<strong>内核模块ntoskrnl.exe</strong>的<strong>下层</strong>部分(上层为执行体),最接近HAL层,负责<strong>线程调度</strong>和<strong>中断、异常的处理</strong>。对于多处理器系统，它还负责同步处理器之间的行为，以优化系统的性能。</p><p>Windows的内核实现了<strong>抢占式线程调度机制</strong>，按照优先级顺序将线程分配到处理器上，并且允许高优先级的线程中断或抢占低优先级的线程。每个线程有一个<strong>基本优先级值</strong>（base priority）和一个<strong>动态优先级值</strong>。根据这俩个值，内核根据调度规则来切换线程，让系统更快响应用户的动作，以及在系统服务和其他低优先级进程之间平衡处理器资源的分配。</p><p>Windows内核按照面向对象的思想来设计，它管理俩种类型的对象：<strong>分发器对象</strong>和<strong>控制对象</strong>。分发器对象实现了各种同步功能，这些对象的状态会影响线程的调度。Windows内核实现的分发器对象包括事件（event）、突变体（mutant）、信号量（semaphore）、进程（process）、线程（thread）、队列（queue）、门（gate）和定时器（timer）。控制对象被用于控制内核的操作但是不影响线程的调度，它包括异步过程调用（APC）、延迟过程调用（DPC），以及中断对象等。</p><h4 id="执行体层"><a href="#执行体层" class="headerlink" title="执行体层"></a>执行体层</h4><p>执行体是<strong>内核模块ntoskrnl.exe的上层部分</strong>，它包含5种类型的函数：</p><ul><li><strong>系统服务调度函数（System Service Dispatch Functions）</strong>：这些函数主要负责响应系统服务请求。当用户模式应用程序请求操作系统服务时，这些函数会被调用。例如<code>NtCreateFile</code>、<code>NtReadFile</code>等函数。</li><li><strong>内核模式支持函数（Kernel Mode Support Functions）</strong>：这类函数提供给其他内核模式组件使用，以执行各种底层任务，如内存管理、进程和线程管理等。例如<code>ExAlloctePool</code>：分配内核池内存、<code>KeSetEvent</code>：设置一个事件对象的状。</li><li><strong>执行对象管理函数（Executive Object Management Functions）</strong>：这些函数用于管理Windows中的各种执行对象，如进程、线程、事件、信号量等。例如 <code>ObOpenObjectByPointer</code> :根据对象指针打开对象、 <code>ExCreateCallback</code>：创建一个回调对象。</li><li><strong>安全引用监视器函数（Security Reference Monitor Functions）</strong>：这些函数用于实现操作系统的安全机制，包括访问控制、权限检查等。例如 <code>SeAccessCheck</code>：检查访问权限。</li><li><strong>I&#x2F;O系统支持函数（I&#x2F;O System Support Functions）</strong>：这些函数支持输入&#x2F;输出系统的操作，包括文件系统的管理、设备驱动程序的交互等。例如 <code>IoWriteErrorLogEntry</code>：写入错误日志条目。</li></ul><p>关于函数前缀，这些函数都以固定的前缀开始，分别属于内核中不同的管理模块：</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401030050046.png" alt="image-20240103005056886"></p><p>与应用层函数不同，在windows操作系统中调用内核函数必须要关注<strong>中断请求级别（IRQL，Interrupt Request Level）</strong>。</p><p>IRQL 是一个表示<strong>中断优先级</strong>的数字，用于确保处理器在处理不同的任务时维持正确的操作顺序和安全性。操作系统内核使用不同的 IRQL 来管理对硬件资源的访问，以及处理不同级别的中断和异常。</p><p>在调用内核函数时，必须要确保当前的IRQL与被调用函数所要求的级别<strong>相符</strong>。不遵守这一规则可能导致系统崩溃或数据损坏。IRQL的级别如下：</p><ol><li><strong>被动级别（PASSIVE_LEVEL）</strong>：这是最低的IRQL级别。在此级别，线程可以被抢占，可以执行任何类型的内核模式代码，包括页面操作。</li><li><strong>APC级别（APC_LEVEL）</strong>：此级别用于阻止异步过程调用（APC）的执行。</li><li><strong>调度级别（DISPATCH_LEVEL）</strong>：在此级别，可以阻止<strong>线程调度</strong>，但仍允许处理硬件中断。很多非分页内存操作需要在此级别或更低级别执行。</li><li><strong>DIRQL（设备IRQL）</strong>：这是特定于设备的中断级别。不同的设备驱动程序可能会使用不同的DIRQL。</li><li><strong>高IRQL（HIGH_LEVEL）</strong>：这是最高的IRQL级别，用于系统关键操作，此时几乎所有的中断都被禁止。</li></ol><p>开发内核模式驱动程序时，合理地管理IRQL至关重要。如果一个函数要求在低IRQL下运行，而当前IRQL较高，就不能直接调用那个函数；反之亦然。不正确的IRQL处理可能导致系统不稳定或蓝屏（BSOD）。</p><p>执行体中除了函数组成，还包含了如图中的<strong>多个重要的组件</strong>，以下：</p><ul><li><strong>内存管理器</strong>：实现了虚拟内存管理，既负责系统地址空间的内存管理，又为每个进程提供了一个私有的地址空间，支持进程之间的内存共享。内存管理器也为缓存管理器提供了底层支持。</li><li><strong>缓存管理器</strong>：它为文件系统提供了统一的数据缓存支持，允许文件系统驱动程序将磁盘上的数据映射到内存中，并通过内存管理器来协调物理内存的分配。</li><li><strong>文件系统</strong>：管理文件和目录的创建、读写和组织。</li><li><strong>进程和线程管理器</strong>：负责进程线程的创建和终止。在Windows中，对于进程和线程的底层支持是在内核层提供的，执行体只是在其基础上提供了一些语义和功能。</li><li><strong>即插即用管理器</strong>：负责列举设备，加载并初始化设备所需的驱动程序。还负责检测系统中的设备变化。</li><li><strong>安全引用监视器（SRM）</strong>：该组件强制在本地计算机上实施安全策略，它守护着操作系统的资源，执行对象的保护和审计。</li><li><strong>配置管理器</strong>：管理系统注册表，提供系统配置和启动信息。</li><li><strong>I&#x2F;O管理器</strong>：实现了与设备无关的输入和输出功能，负责将I&#x2F;O请求分发给正确的设备驱动程序以便进一步处理。</li><li><strong>对象管理器</strong>：它负责创建、管理、删除Windows执行体对象，以及用于表达操作系统资源的抽象数据类型，比如进程、线程和各种同步对象。</li><li><strong>局域网管理器（本地过程调用，LPC）</strong>：负责处理进程之间的通信，管理消息传递和远程过程调用。</li></ul><h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><p>在内核中除了内核模块ntoskrnl.exe和HAL以外，其他模块几乎都以<strong>设备驱动程序</strong>的形式存在。</p><p>Windows中的设备驱动程序，并不一定对应物理设备；它既可以创建虚拟设备，也可以与设备无关，它仅仅是内核的<strong>扩展模块</strong>。从<strong>软件结构</strong>角度而言，可以认为设备驱动程序是Windows内核的一种扩展机制，系统通过设备驱动程序来支持新的物理设备或者扩展功能。</p><p>设备驱动程序是可以加载到系统中的模块，其文件扩展名为**.sys<strong>，其格式是标准的 <strong>PE文件格式</strong>。驱动程序中的代码运行在内核下，尽管它们可以直接操纵硬件，但理想的情况是，</strong>调用HAL**中的函数与硬件打交道，因此，驱动程序往往用C&#x2F;C++语言来编写，从而可以方便地在Windows所支持的体系结构之间进行源代码层次上的移植。</p><p>根据设备驱动程序的<strong>功能和行为</strong>可以将设备驱动程序分为三类：</p><ul><li><strong>即插即用驱动程序</strong>：支持即插即用技术的驱动程序。它们可以在设备连接到计算机时自动被识别和配置，无需用户手动干预。</li><li><strong>非即插即用驱动程序</strong>：不支持即插即用技术的驱动程序。可能在安装时需要用户手动配置。</li><li><strong>文件系统驱动程序</strong>：专门用于处理文件操作的驱动程序，如管理文件的存取、文件系统的结构等。</li></ul><p>即插即用驱动程序，也可以称为<strong>WDM（Windows Driver Model）驱动程序</strong>。WDM是一种设备驱动模型，它提供了一个<strong>统一的框架</strong>，使驱动程序可以在不同版本的WIndwos操作系统上运行。</p><p>WDM通常分为三个层次：</p><ul><li><strong>总线驱动程序</strong>：负责管理总线上的设备，也为总线上的设备提供了访问总线资源的方法。</li><li><strong>功能驱动程序</strong>：负责管理具体的设备，向操作系统提供该设备的功能。</li><li><strong>筛选&#x2F;过滤驱动程序</strong>：监视一个设备的I&#x2F;O请求以及其处理过程，增加或改变一个设备或驱动程序的行为。</li></ul><p>在WDM中，每个硬件设备都有一个设备驱动程序栈（简称<strong>设备栈</strong>），其中包含一个总线驱动程序和一个功能驱动程序，以及零个或多个过滤驱动程序。</p><h4 id="文件系统-存储管理"><a href="#文件系统-存储管理" class="headerlink" title="文件系统&#x2F;存储管理"></a>文件系统&#x2F;存储管理</h4><p><strong>在现代操作系统中</strong>，文件系统是外部存储设备的标准接口，它为应用程序使用这些设备中的数据提供了统一的抽象，多个应用程序和系统本身可以共享使用这些设备。</p><p><strong>在Windows中</strong>，文件系统的接口部分由I&#x2F;O管理器定义和实现，但文件系统的实现部分位于专门的一类驱动程序中。但文件系统接收到I&#x2F;O请求时，它会根据文件系统格式规范，将这些请求转变为更底层的对于外部存储设备的I&#x2F;O请求，通过它们的设备驱动程序来完成原始的I&#x2F;O请求。</p><p>因此，文件系统的驱动程序定义了外部存储设备中数据的<strong>逻辑结构</strong>，使得这些数据可直接被操作系统和应用程序使用。</p><p>这些文件系统驱动程序负责管理磁盘上的文件和目录，处理文件的创建、读取、写入和删除操作，提供了文件存储和访问的基本功能。</p><p>常见的文件系统：</p><ul><li><strong>NTFS（NT File System）</strong>：这是Windows的原生文件系统，其驱动程序为ntfs.sys。NTFS是专门为Windows设计的，它提供了许多高级的如元数据支持、数据压缩加密的功能，同时支持大型存储卷和大文件。</li><li><strong>FAT（File Allocation Table）</strong>：这是从DOS时代发展起来的文件系统格式，格式规范相对简单，目前主要用于兼容老版本的操作系统，以及用于移动设备以便跨操作系统传送数据。</li></ul><p>文件系统的底层是对<strong>存储设备</strong>的管理。大容量存储设备以“<strong>分区（Partition）</strong>”和“<strong>卷（volume）</strong>”来管理整个存储空间。</p><p><strong>分区</strong>是指存储设备上<strong>连续的存储区域</strong>（连续的扇区），而<strong>卷</strong>是指<strong>扇区的逻辑集合</strong>。一个卷内部的扇区可能来自一个分区，也可能来自多个分区，甚至来自不同的磁盘。<strong>文件系统则是卷内部的逻辑结构。</strong></p><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>在Windows操作系统中，网络是由一系列<strong>网络驱动程序</strong>和<strong>网络协议栈</strong>组成。</p><p>Windows内核层中的网络相关组件：</p><ul><li><strong>网络驱动程序（Network Drivers）</strong>：负责管理物理网络接口卡（NIC）或虚拟网络适配器的通信。</li><li><strong>协议栈（Protocol Stack）</strong>：是一个多层次的协议栈，用于处理网络通信。这个协议栈包括了各种网络协议，如TCP&#x2F;IP、UDP、ICMP等。协议栈负责数据包的封装、路由、传输和解包，确保数据在网络中的正确传输。</li><li><strong>套接字（Sockets）</strong>：套接字是应用程序与网络协议栈之间的接口，允许应用程序创建网络连接、发送和接收数据。Windows内核还提供了套接字API，应用程序可以使用这些API与网络进行交互。</li><li><strong>网络服务（Network Services）</strong>：Windwos操作系统还提供了各种网络服务，如DHCP客户端、DNS客户端、网络发现服务等，它们能够进行获取IP地址，解析域名或发现网络设备等操作。</li><li><strong>网络筛选器驱动程序（Network Filter Drivers）</strong>：该驱动程序允许实施网络策略和安全性控制，如防火墙和安全软件可能会使用网络筛选器驱动程序来监视和过滤网络流量。</li></ul><p>Windows为应用程序提供了多种网络API：</p><ul><li><strong>Winsock（Windows Sockets）</strong> ： 套接字API，允许应用程序使用套接字进行网络通信。可以使用Winsock来创建TCP&#x2F;IP和UDP网络连接，发送和接收数据。</li><li><strong>HTTP API</strong>：允许应用程序创建HTTP服务器和客户端，发送HTTP请求、接收HTTP响应，并处理Web服务。</li><li><strong>WebSocket API</strong>：这是一种双向通信的说协议，允许实时数据传输，适用于在线游戏、即时聊天等应用。</li><li><strong>WebRTC API</strong>：一种用于实时音视频通信的开放标准，可以用于创建支持视频会议、实时音频通话等应用程序。</li><li><strong>UPnP API</strong>：一种用于自动发现和配置网络设备的协议。</li><li><strong>WinINet API</strong>：WinINet提供了对Internet资源的访问，包括HTTP、FTP和Gopher等协议，它允许应用程序进行Web页面下载、文件上传和下载等操作。</li><li><strong>Network Management API</strong>：网络管理API，允许应用程序管理网络设置、配置网络连接和查看网络状态。</li></ul><p>这些网络API都提供了用户模式的<strong>动态链接库（DLL）</strong>。当应用程序通过这些DLL发出网络I&#x2F;O请求时，它们将这些请求传递给内核中相应的驱动程序。通常，这些网络API要么通过专门的<strong>系统服务</strong>切换到内核模式，比如命名管道和邮件槽就有专门的系统服务；要么通过标准的<strong>系统服务接口</strong>，比如<code>NtReadFile</code>、<code>NtWriteFile</code>和<code>NtDeviceIoControlFile</code>，由<strong>I&#x2F;O管理器</strong>和<strong>对象管理器</strong>将网络请求转送至对应的驱动程序中。</p><h3 id="Windows子系统"><a href="#Windows子系统" class="headerlink" title="Windows子系统"></a>Windows子系统</h3><p>Windows子系统是Windows操作系统的组成部分，用于支持<strong>不同类型</strong>的应用程序和环境在Windows平台上运行。每个子系统专门设计用于处理特定类型的应用程序和操作环境。</p><p>Windows提供了多种子系统，同时在PE文件格式中的<strong>SubSystem域</strong>指示了可执行文件的子系统类型，即程序应在何种环境下运行；SubSystem域通常包含<strong>一个数字值</strong>，代表不同的子系统类型。</p><p>以下是一些<strong>常见的SubSystem及其对应的子系统</strong>：</p><ol><li><p>**Native (0)**：</p><p>Native子系统表示该PE文件是一个本地的执行文件，通常是驱动程序或操作系统内核组件。这些文件在操作系统内核模式下运行。</p></li><li><p>**Windows GUI (2)**：</p><p>Windows GUI子系统表示该PE文件是一个图形用户界面（GUI）应用程序。它运行在Windows桌面环境中，通常有用户界面和窗口。</p></li><li><p>**Windows CUI (3)**：</p><p>Windows CUI子系统表示该PE文件是一个字符用户界面（CUI）应用程序。它通常是命令行应用程序，没有图形界面，用户通过控制台来与之交互。</p></li><li><p>**OS&#x2F;2 CUI (5)**：</p><p>OS&#x2F;2 CUI子系统表示该PE文件是一个OS&#x2F;2字符用户界面应用程序。这种类型的应用程序通常用于运行在IBM OS&#x2F;2环境中。</p></li><li><p>**Posix CUI (7)**：</p><p>Posix CUI子系统表示该PE文件是一个POSIX兼容的字符用户界面应用程序。它适用于在Windows上运行UNIX&#x2F;Linux应用程序。</p></li></ol><p>Windows子系统中既有用户模式部分，也有内核模式部分。内核模式部分的核心是<strong>win32k.sys</strong>，虽然它的形式是一个驱动程序，但实际上它并不处理I&#x2F;O请求，相反，它向代码<strong>提供大量的系统服务</strong>。从功能上讲，它包含俩部分：<strong>窗口管理</strong>和<strong>图形设备接口</strong>。其中窗口管理部分负责<strong>收集和分发消息</strong>，以及<strong>控制窗口显示</strong>和<strong>管理屏幕输出</strong>；图形设备接口部分包含各种<strong>形状绘制</strong>以及<strong>文本输出功能</strong>。</p><h4 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h4><p>Windows子系统的用户界面管理有一个<strong>层次结构</strong>，通常应用程序只是在一个默认的桌面上运行。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031442520.png" alt="image-20240103144202326"></p><p>每个子系统会话都有自己的会话空间，属于某一个会话的资源将会从该会话空间中分配。当用户登录到Windwos中时，操作系统为该用户建立一个会话；即使用户通过远程桌面或者终端服务连接到一个系统中。系统也会为该用户建立一个单独的会话。</p><p>在一个会话中，有一个<strong>交互式窗口站</strong>，可能还有<strong>非交互式窗口站</strong>。在交互式窗口站中通常有三个桌面：登录桌面、默认桌面和屏幕保护桌面。交互式窗口站有独立的剪贴板、键盘、鼠标、显示器等，在它的三个桌面中，任一时刻只有一个是激活的，输入输出设备归激活的桌面所有。</p><p>在每个桌面，都有一个<strong>顶级窗口列表</strong>，这些窗口往往可以相互重叠，有系统菜单、最大化&#x2F;最小化按钮和滚动条等。通常各个图形界面应用程序的主窗口属于当前桌面的顶级窗口。在Windows中，窗口可以有子窗口，子窗口占据父窗口的客户区域。因此，桌面上的窗口形成了一个层次结构。<strong>一个窗口下总是可以创建它自己的子窗口。</strong></p><p>Windows为常用的窗口定义了一些<strong>窗口类（window class）</strong>。窗口类规定了其对象将如何响应各种信息，包括系统发送给它的消息和用户触发的消息。</p><p>Windows子系统会话有一个<strong>RIT（Raw Input Thread）线程</strong>，负责从输入设备读取原始的输入时间，生成消息寄送到正确的线程消息队列。</p><h4 id="图形设备接口"><a href="#图形设备接口" class="headerlink" title="图形设备接口"></a>图形设备接口</h4><p>Windows的图形引擎有俩方面特点：</p><ul><li>提供了一套与设备无关的编程接口，即GDI，这使得应用程序可以适应各种底层显示设备的差异</li><li>应用程序与图形设备驱动之间通信足够高效。在频繁输出和刷新图形元素的情况下，windows也能提供良好的视觉效果。</li></ul><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031515131.png" alt="image-20240103151555070"></p><p>上图是Windows子系统定义的图形体系结构。win32k.sys通过DDI（显示设备驱动程序接口）与现实驱动程序打交道，而显示驱动程序通过ENG（图形引擎接口）调用Win32k.sys中图形引擎的功能。</p><p>视频端口驱动程序实际上是一个动态链接库，用于辅助视频小端口驱动程序实现一些公共的、与图形有关的功能，以及为小端口驱动程序提供一个与系统内核和执行体打交道的环境。视频小端口驱动程序则直接负责的硬件资源管理和控制。</p><h3 id="系统线程和系统进程"><a href="#系统线程和系统进程" class="headerlink" title="系统线程和系统进程"></a>系统线程和系统进程</h3><p><strong>系统线程</strong>则是一些特殊线程，与普通用户线程不同，系统线程不属于任何特定的用户进程，它直接运行在内核模式下。</p><p>一些常见的系统线程：</p><ul><li><strong>Idle线程</strong>：它的任务是在系统没有其他任务要执行时，占用CPU周期并降低CPU功耗，它通常属于最低优先级，以确保在需要时可以立即释放CPU资源给其他任务。</li><li><strong>Deferred Procedure Call (DPC) 线程</strong>：DPC线程是用于处理延迟的硬件中断请求的系统线程。当硬件设备产生中断请求时，DPC线程负责处理这些请求并执行相应的处理程序。</li><li><strong>System线程</strong>：System线程执行一些关键的内核操作，如系统调度、中断处理、内存管理等。它是操作系统的核心部分，用于协调和管理其他系统线程和用户进程。</li></ul><p>系统线程中还有一组<strong>系统辅助线程（system worker thred）</strong>，它们代表操作系统或者其他的应用进程来完成一些特殊的工作。实际上，系统辅助线程是一个<strong>线程池</strong>，Windows在系统初始化时创建了一定数量的辅助线程，而且随着辅助线程的负载的变化，执行体也会动态地创建一些辅助线程，以满足系统负载的变化需求。</p><p>在Windows操作系统中，有一些重要的<strong>系统进程</strong>，它们负责管理和控制操作系统的不同方面。</p><p>一些常见的系统进程：</p><ul><li><strong>系统空闲进程（Idle）</strong>：该进程的PID为0，其中每个处理器或核对应有一个线程。</li><li><strong>System 进程</strong>：这是操作系统的好恶心进程，PID为4。它负责管理内核模式下线程、设备驱动程序、中断处理和其他核心人物。</li><li><strong>会话管理器（smss.exe）</strong>：Windows系统中创建的第一个用户模式进程，在Windows启动过程中创建环境变量，（启动了子系统进程csrss.exe和登录进程winlogon.exe）。另外，它还负责创建新的终端服务器会话，包括建立会话空间的数据结构，为新建的终端服务器加载子系统。</li><li><strong>登录进程（winlogon.exe）</strong>：负责处理交互用户的登录和注销。</li><li><strong>Windows子系统进程（csrss.exe）</strong>：负责为用户提供一个子系统环境。</li><li><strong>本地安全权威子系统进程（lsass.exe）</strong>：负责本地系统安全策略。</li><li><strong>Shell进程（explorer.exe）</strong>：Windows的默认Shell，它提供了系统与用户打交道的各种界面，包括开始菜单、任务栏、资源管理窗口等几乎所有Windows用户都熟悉的界面。</li><li><strong>服务控制管理器（services.exe）</strong>：负责Windows的系统服务，指一些特殊的进程。</li></ul><h2 id="内核基本概念"><a href="#内核基本概念" class="headerlink" title="内核基本概念"></a>内核基本概念</h2><p>Windows内核中的各个组件并非单纯的独立模块，相反地，组件之间不可避免地包含了复杂的依赖关系，甚至存在交叉引用。下面是一些Windows内核中的基本概念。</p><h3 id="处理器模式"><a href="#处理器模式" class="headerlink" title="处理器模式"></a>处理器模式</h3><p>在Intel x86处理器上，<strong>段描述符</strong>有一个2位长度的特权级：0表示最高特权级，3表示最低特权级。也就是CPU的权限级别0环和3环，分别对应内核模式和用户模式。</p><p>处理器有许多指令只有在<strong>零</strong>环内才可以使用，例如I&#x2F;O指令、操纵内部寄存器指令等，当处理器处于用户模式时，它处于一种相对隔离的状态：<strong>能够执行的指令有限，能够访问的内存也是有限的</strong>（用户代码和内核代码有各自的运行环境）。一旦越过这些限制，就会引发<strong>处理器异常</strong>，此时操作系统会捕获这些异常，并决定处理器是否继续执行。</p><p>用户模式下，处理器<strong>只能</strong>访问用户地址空间，而在内核模式下，处理器<strong>不仅</strong>可以访问用户地址空间，<strong>也</strong>可以访问系统地址空间。在内核模式下的代码和数据都是<strong>共享</strong>的，所有的进程一旦其指令流进入到内核模式下，则系统地址空间的代码和护具都是相同的。</p><p>一个指令流（即线程）在执行时，在以下情况会发生模式切换：</p><ul><li>用户模式代码<strong>触发了异常</strong>，则控制流进入到内核模式，内核中的异常处理函数可以决定该控制流是否继续执行。</li><li>用户模式代码执行时，被一个<strong>中断</strong>打断，控制流进入特权模式，等中断处理例程完成后，它若调用<code>iret/iretd</code>指令，则控制流恢复到用户模式下。</li><li>执行特殊的<strong>模式切换指令</strong>，如Intel x86的<code>sysenter</code>指令，从用户模式切换到内核模式。若想从内核模式切换到用户模式1，通常使用<code>sysexit</code>、<code>iret/iretd</code>这样的指令。</li></ul><p>由于系统空间是所有进程共享的，所以，任何一个进程在执行内核模式的代码时，实际上是在使用操作系统的服务。在Windows体系结构中，内核模式向上优一个执行体API，对于应用程序而言，这便是系统服务。</p><p>Windows将这些系统服务组织成了一张表，称为<strong>SDT（Service Descriptor Table，服务描述符表）</strong>。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>任何一个进程都定义了它自己完整的4GB地址空间（虚拟内存空间），在内存空间分布一图中，将其划分成2GB内核空间以及2GB应用空间，换句话说，内核空间是所有进程共享的，也称作<strong>系统地址空间</strong>，剩下的2GB空间才是它自己私有的，也叫<strong>进程地址空间</strong>。</p><p>为了有效管理2GB的系统地址空间，Windows将2GB划分成了一些固定的区域，主要包括：内核模块映像、PFN数据库、换页内存池、非换页内存池、会话空间、系统缓存区、系统视图以及页表等。</p><p><strong>分页机制</strong>：</p><p>Windows使用<strong>分页机制</strong>管理虚拟内存和物理内存。它将虚拟内存和物理内存划分成固定大小的页面，通过映射这些页面来实现虚拟地址到物理地址的转换。</p><p>通常操作系统将内存划分为<strong>大小固定的页面</strong>，通常为 <strong>4KB</strong>、8KB 或其他大小。这些页面是虚拟内存和物理内存的<strong>基本单位</strong>；之后操作系统将进程的虚拟地址空间也划分成页面大小的块。当程序访问进程的虚拟地址时，操作系统将虚拟地址转化成相应的物理地址。</p><p>为了实现虚拟地址到物理地址的转换，需要使用到<strong>页面表</strong>。</p><ul><li><strong>页面表</strong> 是操作系统中的一个数据结构，用于记录虚拟地址空间中每个页面与实际物理内存中的对应关系。页面表的条目存储了虚拟页号到物理页号的映射关系。</li><li>页面表中的每个条目称为<strong>页表项（Page Table Entry，PTE</strong>）。每个 PTE 存储了虚拟页号到物理页号的映射，以及一些额外的控制信息，例如页面是否在物理内存中、是否被修改等。</li></ul><p>当程序访问进程的虚拟地址时，<strong>MMU</strong>负责将这个虚拟地址通过页面表转化成物理地址。</p><p>如果虚拟页已经在物理内存中，则直接获取物理地址。如果虚拟页不在物理内存中，就需要进行<strong>页面调度</strong>。</p><p><strong>页面调度</strong>：</p><ul><li><p>如果虚拟页不在物理内存中，会先引发一个 <strong>缺页异常</strong>。这时，操作系统需要根据页表中的信息确定要将哪一页加载到物理内存中。</p></li><li><p>然后操作系统会将当前没用的物理页写入磁盘中，将需要的虚拟页加载入物理页。</p></li></ul><p><strong>从内存中获取数据的过程</strong>：</p><ul><li>程序访问进程的虚拟地址</li><li>MMU在通过页面表查询虚拟地址对应的虚拟页是否在物理内存中</li><li>若在，直接获取物理地址，返回数据；</li><li>若不在，引发缺页异常，MMU在页面表中查找对应的虚拟页，通过页面调度将虚拟页加载到物理内存中</li><li>获取物理地址，返回数据。</li></ul><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031733063.png" alt="image-20231213214736149"></p><p>​<strong>至于数据在物理内存中还是虚拟内存中是没有规律的，取决于数据使用的频繁程度。</strong></p><p><strong>内存页面管理算法</strong></p><p>在系统地址空间中，不同的区域使用并不完全相同的内存页面管理算法，较为典型的有以下三种：</p><ul><li><strong>非换页内存池</strong>：这部分内存区域在初始化时就已经被映射到物理页面，所以Windows利用空闲链表的做法，按照不同的粒度（1、2、3、&gt;&#x3D;4个页面大小），将空闲页面链接起来。空闲页面本身即链表中的节点，因而这些链表无需额外的内存空间（除了头节点）。申请和释放页面的操作实际上是针对空闲链表来进行的。</li><li><strong>换页内存池</strong>：在换页内存池区域，空闲的页面并没有被映射好物理页面，Windows使用位图来管理页面的分配。分配连续的多个页面，即从位图中找到连续的零位。</li><li><strong>系统PTE区域</strong>：这部分内存区域存放的并非PTE，而只是表示这部分地址范围是以PTE的形式来管理的，即把PTE当做资源来管理。当内核需要一段虚拟地址来映射物理页面时，它可以使用系统PTE区域中的地址。</li></ul><p>以上这些内存区域按照<strong>页面粒度</strong>来管理其分配情况，Windows执行体在这些系统内存区域管理的基础上，还提供了一组更小的粒度（8B的倍数，最小位8B）的内存管理，包括<strong>执行体换页内存池</strong>和<strong>执行体非换页内存池</strong>。这些内存池通过<strong>空闲链表</strong>记录下每个已申请页面中的空闲内存块；当释放内存时，自动与相邻的空闲块合并以构成更大的空闲内存块。内核其他组件或驱动程序通过执行体暴露的API函数（例如<code>ExAllocatePoolWithTag</code>和<code>ExFreePoolWithtag</code>）来使用这些内存池。</p><p>进程地址空间是随进程一起被创建的，每个进程都有它自己的页目录页面，其中有一半的<strong>页目录项（PDE）</strong>是共享的，即系统地址空间部分，余下一半初始化为零。随着进程中的映像文件（包括.exe文件和各DLL文件）被加载进来，以及各个模块的初始化代码被执行，进程地址空间将被建立起来。</p><p>进程地址空间按照其<strong>虚拟地址是否被分配或保留</strong>来进行管理，用户模式代码通过Windows API函数 <code>VirtualAlloc</code> 和 <code>VirtualFree</code>来申请或释放地址范围，而内核中的虚拟内存管理器则通过一颗<strong>平衡二叉树</strong>来管理进程地址空间被使用的情况。数中的每个节点为<strong>VAD（虚拟地址描述符，Virtual Address Descriptor）</strong>，描述了一段连续的地址方位。</p><p>在VAD树中，有一种重要的节点类型为<strong>内存区对象（section object）</strong>，它是Windows平台上俩个或多个进程之间共享内存的一种方式。</p><p>除了对系统地址空间和进程地址空间的管理，内存管理器另一个重要的任务是<strong>管理有限的物理内存</strong>。在WIndows的系统地址空间中，专门保留了一个称为<strong>PFN数据库（Page Frame Number Database，页帧编号数据库）</strong>的区域。</p><p>当系统中的进程需要使用大量内存时，内存管理其如何将有限的物理页面分配给那些需要使用内存的进程？利用Windows工作集管理器。<strong>工作集（working set）</strong>是指<strong>一个进程当前正在使用的物理页面的集合</strong>。Windows系统中除了<strong>进程工作集</strong>，还有<strong>系统工作集</strong>（即系统空间中动态映射的页面集合）和<strong>会话工作集</strong>（即会话空间中的代码和数据区）。</p><p>工作集管理器运行在一个称为<strong>平衡管理器（balance set manager）</strong>的<strong>线程</strong>中，它的作用除了<strong>触发工作集管理器</strong>，还定期<strong>触发进程&#x2F;栈交换器（process&#x2F;stack swapper）</strong>。进程&#x2F;栈交换是另一个单独的<strong>线程</strong>，一旦被唤醒，就会将满足特定条件的进程和栈换入内存或换出内存。</p><h3 id="进程和线程管理"><a href="#进程和线程管理" class="headerlink" title="进程和线程管理"></a>进程和线程管理</h3><p><strong>进程（process）</strong>定义了一个执行环境，包括它自己的私有空间、一个句柄表、以及一个安全环境；<strong>线程（thread）</strong>是一个控制流，有自己的<strong>调用栈（call stack）</strong>，记录它的执行历史。</p><p>一个进程包含一个或多个线程。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031958530.png" alt="image-20240103195851417"></p><p>如图，用户模式下的进程只能访问进程地址空间，若在内核模式下，就可以访问真个地址空间。</p><p>在Windows内核结构中，进程和线程的核心机制是在微内核中实现的，而管理机制是在执行体中实现的。例如，微内核负责线程调度，而线程进程的创建和初始化由执行体完成。</p><p>windows实现了<strong>抢占式线程调度</strong>，每个线程都有一个基本优先级和动态优先级。本质上每个线程都处于俩种状态之一：满足继续执行的条件，正在排队或已经执行；不满足继续执行的条件，处于等待状态，或者它的调用栈升职所处的进程已经被换出内存。在前一种情况下，线程按照优先级排队执行；对于多处理器系统，排队过程要更为复杂，不仅要处理多个队列，还要考虑每个处理器的就绪线程队列的平衡程度。还需要考虑处理器亲和性。</p><p>关于作业和迁程，<strong>作业（job）</strong>是一个执行体支持的内核对象，它使得一个或多个进程被当做一个整体来加以管理和控制。管理程序通过Windows API 可以控制一个作业小号系统资源（CPU或内存）的各种限制，例如用户模式CPU时间的限制、进程的处理器亲和性、工作集的最大值和最小值、虚拟内存的使用限制等。<strong>迁程（fiber）</strong>是一种用户线程，它对于内核是不可见的，由kernel32.dll实现。应用程序可以在一个线程环境中创建多个迁程，然后手动控制它们的执行。迁程不会被自动执行，应用程序必须显式地选择某个迁程来执行，而且一旦迁程运行起来，要么一直运行到它退出，要么运行到它显式地切换至另一个迁程。</p><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p><strong>中断（interrupt）</strong>是指处理器外部事件（如硬件设备）触发的信号，它会中断当前的处理器活动。<strong>异常（Exceptions）</strong>指程序执行过程中出现的非正常或意外情况，由处理器内部事件（如执行了错误指令）触发。</p><p>尽管中断和异常的触发来源和方式不同，但Intel x86处理器内部使用<strong>同一套陷阱机制</strong>来处理中断和异常，它利用<strong>IDT（Interrupt Descriptor Table，中断描述符表）</strong>，将每个中断或异常与一个处理该中断或异常的服务例程联系起来，因而一旦发生异常或中断，该相应的服务例程将被执行。Windows在此基础上，添加了一种更灵活的机制，允许设备驱动程序为特定的<strong>中断向量</strong>添加它的<strong>中断服务例程（ISR，Interrupt Service Routine）</strong>。一个中断向量允许连接多个<strong>中断对象（interrupt object）</strong>，这里中断对象是一种封装了中断服务例程的<strong>内核对象</strong>。当中断发生时，这些中断对象中的服务例程都有机会处理该中断。通过中断对象机制，设备驱动程序可以在不操纵IDT的情况下加入它们的中断服务例程；另一方面，多个硬件设备也可以共享同样的硬件中断向量。</p><p>执行体层中介绍过<strong>中断请求级别IRQL</strong>。</p><p>异常是程序指令流执行过程中的<strong>同步处理过程</strong>，既可以由<strong>处理器硬件</strong>产生，也可以由<strong>指令流软件</strong>产生。Windows为所有需要处理的异常都提供了<strong>异常处理器（exception handler，即异常处理例程）</strong>。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>在现代操作系统中，由于多处理器、多核或者中断各种<strong>并发性（concurrency）</strong>因素的存在，同样的代码可能被并发执行，而数据也可能被并发访问。在这种情况下，对于可能被并发访问的数据进行必要的<strong>同步（synchronization）保护</strong>是一种常见的编程实践。</p><p>一些同步中会遇到的概念：</p><ul><li>关于<strong>锁</strong>。什么是锁？锁是一种同步机制，用于确保在同一时刻只有<strong>一个线程</strong>能够访问共享资源；也就是保护<strong>临界区</strong>，确保在任何时刻只有<strong>一个线程</strong>可以进入临界区执行操作。锁包括<strong>互斥锁</strong>、<strong>自旋锁</strong>、<strong>读写锁</strong>等不同类型。</li><li><strong>临界区</strong>。什么临界区？临界区是用于保护共享资源免受多个线程同时访问的一种同步机制：当一个线程进入临界区时，其他线程必须等待，直到第一个线程离开临界区。常用于用户模式下。</li></ul><p>Windows根据执行环境中的<strong>IRQL大于APC_LEVEL 或者等于PASSIVE_LEVEL</strong>，将同步机制分为“<strong>不依赖线程调度的同步机制</strong>”和“<strong>基于线程调度的同步机制</strong>”。</p><p>不依赖线程调度的同步机制主要是在<strong>IRQL的高优先级</strong>下执行的，通常用于中断处理程序和内核模式代码中，以确保在处理中断或执行关键内核代码时，不会被其他线程打断。常见的不依赖线程调度的同步机制包括：</p><ul><li><strong>自旋锁（Spin Lock）</strong>：自旋锁用于在多个线程之间互斥的访问共享资源，本质上是一种<strong>忙等待（busy-wait）</strong>，意思是线程会<strong>一直自旋（忙等待）直到锁可用为止，而不会被挂起等待。</strong>常使用在高IRQL下，因为此时是不允许切换线程的，使用自旋锁可以确保关键代码不会被其他线程打断。一些<strong>自旋锁扩展</strong>：执行体自旋锁（支持共享和独占的语义）、排队自旋锁（queued spin lock）和栈内排队自旋锁（in-stack queued spin lock）。</li><li><strong>中断服务例程（ISR）</strong>：ISR用于响应硬件中断，当硬件设备触发中断时，操作系统会立即执行ISR来处理中断。ISR运行在IRQL的高优先级下，不允许进行线程调度，以确保快速响应中断。</li><li><strong>延迟过程调用（Deferred Procedure Call，DPC）</strong>：DPC用于延迟执行一些代码块或处理程序，常与中断处理有关。当硬件设备触发中断时，操作系统会将<strong>中断服务例程（ISR）</strong>用于快速响应中断，但有时需要执行一些耗时的操作，例如数据传输或资源释放，这时就会使用DPC来延迟执行这些操作。</li></ul><p>另一种基于线程调度的同步机制：当一个线程的<strong>执行条件</strong>不满足时，该线程进入等待状态，系统将控制权交由其他满足<strong>执行条件</strong>但没有得到处理器资源的线程；以后，当该线程的<strong>执行条件</strong>满足时，它又有机会继续执行。这里的执行条件正是Windows提供的线程同步机制中的<strong>语义</strong>。Windows定义了统一的机制来支持各种线程同步原语：<strong>分发器对象（dispatcher object）</strong>，其数据结构头部为<strong>DISAPATCH_HEADER</strong>。</p><p>常见的分发器对象：</p><ul><li><strong>事件（event）</strong>：用于线程之间的通信和同步，它有俩种状态：已触发和未触发。事件可以用于线程等待某个事件发生，或者通知其他线程事件的发生。</li><li><strong>互斥量（Mutex）</strong>：互斥量用于确保在同一时刻只有一个线程能够访问共享资源。它允许线程请求锁定，当一个线程获得锁定时，其他线程必须等待，直到锁被释放。</li><li><strong>信号量（Semaphore）</strong>：用于控制对共享资源的并发访问。它维护一个计数器，允许指定数量的线程同时访问资源。</li><li><strong>条件变量（Condition Variable）</strong>：条件变量用于线程之间传递信号和等待特定条件的发生。通常与互斥量一起使用，用于等待某个条件满足后执行操作。</li><li><strong>读写锁（Read-Write Locks）</strong>：读写锁用于控制对共享资源的读和写，它允许多个线程同时读取资源，但只允许一个线程写入资源。</li><li><strong>计数器对象（Counting Semaphore）</strong>：一种特殊的信号量，它可以增加和减少计数器的值，通常用于跟踪资源的可用性或完成的任务数量。</li></ul><p><strong>互斥锁（Mutex）</strong>是一种基于线程调度的同步机制，它用于确保在同一时刻只有一个线程能够访问共享资源。当一个线程获得互斥锁的所有权后，其他线程必须等待，直到该线程释放锁。</p><p>关于互斥锁和自旋锁：互斥锁基于线程调度，而自旋锁不依赖线程调度；还有一个区别是线程尝试获取锁时，如果该锁被占用，线程是被挂起还是一直自旋；互斥锁适用于长时间的临界区和资源竞争激烈的情况，而自旋锁适用于非常短暂的临界区。</p><p>Windows在上述基础上，实现了同步语义更为丰富的一些同步机制，包括：<strong>快速互斥体（fast mutex）</strong>、<strong>守护互斥体（guarded mutex）</strong>、<strong>执行体资源（executive resource）</strong>和<strong>推锁（push lock）</strong>。</p><h2 id="内核重要数据结构"><a href="#内核重要数据结构" class="headerlink" title="内核重要数据结构"></a>内核重要数据结构</h2><p>windows内核中一些常见的数据结构。</p><h3 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h3><p>内核对象是Windows内核中一种重要的<strong>数据结构管理机制</strong>。应用层的进程、线程、文件、驱动模块、事件、信号量等对象或者打开的句柄在内核中都有与之对应的内核对象。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040002657.png" alt="image-20240104000229599"></p><p>如图，一个Windows内核对象可以分为<strong>对象头</strong>和<strong>对象体</strong>俩部分。在对象头中至少有一个<strong>OBJECT_HEADER</strong>和<strong>对象额外信息</strong>。对象体紧接着对象头中的OBJECT_HEADER。一个对象指针总是<strong>指向对象体</strong>而不是对象头。如果要访问对象头，需要将对象体指针<strong>减去</strong>一个特定的偏移值，以获取OBJECT_HEADER结构，通过OBJECT_HEADER结构定位从而访问其他对象结构辅助。对象体内部一般会有<strong>1个type</strong>和<strong>1个size</strong>成员，用来表示<strong>对象的类型和大小</strong>。</p><p>Windows内核对象可以分为如下3种类型：</p><ol><li><p><strong>Dispatcher对象</strong></p><p>这种对象在对象体开始位置了一个<strong>公共数据结构DISPATCHER_HEADER</strong>，其结构代码如下：</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040028701.png" alt="image-20240104002800628"></p><p>包含了<code>DISPATCHER_HEADER</code>结构的内核对象都以<strong>字母“K”开头</strong>，表明这是一个内核对象，例如KPROCESS、KTHREAD，但以字母“K”开头的内核对象不一定是Dispatcher对象。包含该结构的内核对象都是<strong>可以等待的（waitable）</strong>，也就是说，这些内核对象可以作为参数传给内核的<code>KewaitForSingleObject()</code>和<code>KeWaitForMultipleObjects()</code>函数，以及应用层的<code>WaitForSingleObject()</code>和<code>WaitForMultipleObject()</code>函数。</p></li><li><p><strong>I&#x2F;O对象</strong></p><p>I&#x2F;O对象在对象体开始位置没有DISPATCHER_HEADER结构，但通常会放置一个与type和size有关的整型成员，以表示该内核对象的<strong>类型</strong>（例如文件内核对象的类型为26）和<strong>大小</strong>。常见的I&#x2F;O对象包括DEVICE_OBJECT、DRIVER_OBJECT、FILE_OBJECT等。</p></li><li><p><strong>其他对象</strong></p><p>除了Dispatcher对象和I&#x2F;O对象，剩下的都属于<strong>其他内核对象</strong>。其中有俩个常用的内核对象，分别是<strong>进程对象（EPROCESS）</strong>和<strong>线程对象（ETHREAD）</strong>。</p><p>EPROCESS用于在内核中管理进程的各种信息，如<strong>进程ID、进程状态、内存管理信息</strong>等。所有进程的EPROCESS内核结构都被放入一个<strong>双向链表</strong>，R3在枚举系统进程的时候，通过遍历这个链表获得了进程的列表。因此有的Rookit会试图将自己进程的EPROCESS结构从这个链表摘掉，从而达到隐藏自己的目的。</p><p><strong>EPROCESS结构</strong>中的一些关键数据如下：</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040040028.png" alt="image-20240104004007952"></p><p>调用下面俩个内核函数可以获得进程的EPROCESS结果。</p><p><code>PsLookupProcessByProcessId()</code>函数，根据<strong>进程PID</strong>拿到进程的EPROCESS结构；<code>PsGetGurrentProcess()</code>函数，<strong>直接</strong>获取当前进程的EPROCESS结构。</p><p><strong>ETHREAD结构</strong>是线程的内核管理对象。它代表Windows中的一个线程，<strong>包含了线程的执行上下文、调度信息。</strong></p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040046513.png" alt="image-20240104004659468"></p><p>EPROCESS、KPROCESS、ETHREAD、KTHREAD结构之间的关系如下图。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040047536.png" alt="image-20240104004747444"></p><p>可以看出，EPROCESS和ETHREAD结构都是通过<strong>双向循环链表</strong>组织管理的。一个EPROCESS结构中包含一个KPROCESS结构，而在一个KPROCESS结构中又有一个指向ETHREAD结构的指针。在ETHREAD结构中，又包含了KTHREAD结构成员。</p></li></ol><p></p><h3 id="SSDT"><a href="#SSDT" class="headerlink" title="SSDT"></a>SSDT</h3><p><strong>系统服务描述表（System Services Descriptor Table，SSDT）</strong>其在内核中的实际名称是 “<strong>KeServiceDescriptorTable</strong>”。</p><p>它用于<strong>处理应用层通过kernel32.dll下发的各个API操作请求</strong>。ntdll.dll中的API是一个简单的包装函数，当kernel32.dll中的API通过ntdll.dll时，会先完成对参数的<strong>检查</strong>，再调用一个<strong>中断</strong>（<code>int 2Eh</code>或者<code>SysEnter</code>指令），从而实现从R3层进入R0层，并将要调用的服务号（也就是SSDT数组中的<strong>索引号</strong>index值）存放到寄存器EAX中，最后根据存在EAX中的索引值在SSDT数组中调用指定的<strong>服务</strong>（Nt*系列函数）。如下图：</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401041606154.png" alt="image-20240104160639068"></p><p>SSDT表的结构定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceDescriptorEntry</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *ServiceTableBase;<span class="hljs-comment">//表的基地址</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *ServiceCounterTableBase;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> NumberOfServices;<span class="hljs-comment">//表中服务的个数</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *ParamTableBase;<br>&#125; ServiceDescriptorTableEntry_t,<br>*PServiceDescriptorTableEntry_t;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br></code></pre></td></tr></table></figure><p>其中较为重要的俩个成员为<code>ServiceTableBase</code>（SSDT表的基地址）和<code>NumberOfServices</code>（表示系统中SSDT服务函数的个数）。<strong>SSDT表实际上是一个连续存放该函数指针的数组</strong>。</p><p>SSDT表的导入方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__declspec(dllimport) ServiceDescriptorTableEntry_t KeServiceDescriptorTable;<br></code></pre></td></tr></table></figure><p>由此可以知道SSDT表的基地址和SSDT函数的索引号（index），从而求出对应的服务函数地址。在x86平台上，它们之间满足如下规则：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">FuncAddr</span> = <span class="hljs-title class_">KeServiceDescriptorTable</span> + <span class="hljs-number">4</span> * index<br></code></pre></td></tr></table></figure><p>与x86平台上直接在SSDT中存放SSDT函数地址不同，在x64平台上，SSDT中存放的是索引号锁对象的SSDT函数地址和SSDT表基地址的偏移量左移4位的值，因而计算公式变为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">FuncAddr</span> = ([<span class="hljs-title class_">KeServiceDescriptorTable</span> + index * <span class="hljs-number">4</span>] &gt;&gt; <span class="hljs-number">4</span> + <span class="hljs-title class_">KeServiceDescriptorTable</span>)<br></code></pre></td></tr></table></figure><p>通过这个公式，只要知道SSDT表的基地址和对应函数的索引号，就可以将对应位置的服务函数替换成自己的函数，从而完成SSDT Hook过程了。</p><h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p>操作系统会为每个进程设置一个数据结构，用来记录进程的相关信息。该结构就是<strong>PEB（Process Environment Block，进程环境块）</strong>，PEB存在于用户地址空间中，记录了进程的相关信息。</p><p>在NT中，PEB位于进程空间的<code>FS:[0x30]</code>处。同时，TEB中的 <code>ProcessEnvironmentBlock</code> 就是PEB结构的地址，其结构的0x30偏移处是一个指向PEB的指针。</p><p>因此，访问PEB有俩种方法：</p><ol><li><p>直接获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax, dword ptr fs:[30h]   ; fs:[30]里存放即是PEB地址<br></code></pre></td></tr></table></figure></li><li><p>通过TEB获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax, dword ptr fs:[18h]     ;此时eax里为TEB的指针<br>mov eax, dword ptr [eax+30h];此时eax里为PEB的指针<br></code></pre></td></tr></table></figure></li></ol><p>PEB结构（部分）：<br><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401041650999.png" alt="image-20231226195733857"></p><p>其中，<code>BeingDebugged</code>成员用于指定该进程是否处于被调试状态，该值为0时进程未处于调试状态，若该值为非零值，则进程处于调试状态。（可以使用Windows API，如<code>IsDebuggerPresent</code>、<code>CheckRemoteDebuggerPresent</code>函数来访问该成员）</p><p><strong>Ldr</strong>字段也是一个很重要的成员，该字段指向的结构记录了进程加载进内存的所有模块的基地址，通过Ldr指向的三个链表就可以找到<code>kernel32.dll</code>的基地址。</p><h3 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h3><p><strong>TEB（Thread Environment Block，线程环境块）</strong>同样位于应用层之中。它包含了系统频繁使用的一些与线程相关的数据，进程中的每个线程都有一个自己的TEB。一个进程的所有TEB都存放在从0x7FFDE000开始的线性内存中，每4KB为一个完整的TEB。</p><p>在NT中，<code>FS:[0]</code>的地址指向了TEB结构，这个结构的开头是一个<strong>NT_TIB</strong>结构，具体（部分）如下：</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312262012839.png" alt="image-20231226201240784"></p><p>NT_TIB结构的<strong>0x18</strong>偏移处是一个<strong>Self指针</strong>，指向这个结构自身，也就是TEB结构的开头。TEB结构的<strong>0x30</strong>偏移处是一个指向PEB的指针。</p><p>在TEB结构的<strong>0xE10</strong>偏移处有个字段<code>TlsSlots[]</code>，是一个无类型的指针数组（TLS存储槽），它的大小是40h字节。也就是说，一个线程同时存在的动态TLS不能超过64项。</p><p>可以通过NtCurrentTeb函数调用和FS段寄存器俩种方法来访问TEB结构：</p><ol><li><p>NtCurrentTeb函数调用</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312262020779.png" alt="image-20231226202035720"></p></li><li><p>FS段寄存器访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax, dword ptr fs:[18h]  <br></code></pre></td></tr></table></figure></li></ol><h3 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h3><p>Windows注册表也可以被视为一种<strong>特殊</strong>的数据结构，它是一个<strong>层次结构数据库</strong>，用于存储和组织系统配置信息、应用程序设置和其他系统相关的数据。</p><p>Windows提供了一些API供应用程序访问注册表，例如<code>RegOpenKeyEx</code>、<code>RegCreateKeyEx</code>等。这些API运行开发人员在应用程序中读取、写入、编辑和删除注册表中的键值和数据。</p><p>在Win10中通过Win+R输入regedit即可查看注册表。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401041702378.png" alt="image-20240104170258314"></p><p>如上图，Windows注册表是一个树状（层次）结构：</p><ol><li>每个节点是一个键（key）或值（value）。</li><li>键是一个容器，好比文件系统中的目录，它可以包含其他的键（子键）和值。注册表中的每个键都有一个唯一的名称，用于标识它。</li><li>值存储的是数据，好比是文件系统中的文件。数据可以是字符串、整数、二进制数据等不同的类型。</li><li>注册表的根也是一个键，称为根键。一般为5个根键，常见的根键包括HKEY_LOCAL_MACHINE（存储计算机范围的配置信息）、HKEY_CURRENT_USER（存储当前用户的配置信息）等。</li></ol><p>在内核之中，执行体包含了一个称为“<strong>配置管理器</strong>”的组件，它是注册表的真正实现。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows反调试技术</title>
    <link href="/2024/04/02/Windows%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/04/02/Windows%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows反调试"><a href="#Windows反调试" class="headerlink" title="Windows反调试"></a><strong>Windows反调试</strong></h1><h1 id="通过-API-调用"><a href="#通过-API-调用" class="headerlink" title="通过 API 调用"></a>通过 API 调用</h1><h2 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent"></a>IsDebuggerPresent</h2><p><code>IsDebuggerPresent</code>函数通过获取进程环境块（PEB）中的<code>BeingDebugged</code>标志来检测进程是否处于调试状态。</p><p>其实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">IsDebuggerPresent</span><span class="hljs-params">(VOID)</span><br>&#123;<br><span class="hljs-keyword">return</span> NtCurrentPeb() -&gt; BeingDebugged;<br>&#125;<br></code></pre></td></tr></table></figure><p>BeingDebugged是PEB中的一个标志。每个运行中的进程都有一个PEB结构，其<strong>0x02偏移处</strong>就是BeingDebugged标志，如果程序处于调试状态，该标志的值会被设置为<strong>非零值</strong>。相关Windows API就是通过访问该值来进行反调试操作。</p><p>如何访问PEB？PEB的地址储存在另一个名为线程环境块（TEB）中。</p><p>Windows在调入进程、创建线程时，操作系统会为每个线程分配TEB，而且FS段寄存器总是被设置成使得<code>FS:[0]</code>指向当前线程的TEB数据。而TEB结构中的<strong>0x30偏移处</strong>正是PEB的地址。</p><p>Windows一般通过TEB间接获取PEB的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,fs:[18h]//获取当前线程的TEB地址<br>mov eax,[eax+30h]//在TEB偏移30h处获得PEB地址<br></code></pre></td></tr></table></figure><p>TIB+18h处为Self。它是TIB的自身指针，指向TEB的首地址。因此也可以省略它直接使用<code>fs:[30h]</code>得到自己进程的PEB。</p><p>如何过掉IsDebuggerPresent？</p><p>示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br>BOOL <span class="hljs-title function_">CheckDebugger</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 直接调用IsDebuggerPresent函数，不需要定义额外的指针</span><br>    <span class="hljs-keyword">return</span> IsDebuggerPresent();<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (CheckDebugger())<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] 进程正在被调试 \n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] 进程没有被调试 \n&quot;</span>);<br>    &#125;<br><br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一种方法是IDA中在<strong>修改恶意代码</strong>（例如jz跳转将其改为jnz，或者修改cmp）</p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311337977.png"><p>第二种使用xdbg，在数据窗口使用“Ctrl+G”搜索<strong>fs:[30]+2</strong>；</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311334489.png" alt="image-20231231133408373"></p><p>这里的01就是BeingDebugged标志，将其用“Ctrl+E”修改成00，运行程序，程序输出：</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311335298.png" alt="image-20231231133520252"></p><h2 id="CheckRemoteDebuggerPresent（NtQueryInformationProcess）"><a href="#CheckRemoteDebuggerPresent（NtQueryInformationProcess）" class="headerlink" title="CheckRemoteDebuggerPresent（NtQueryInformationProcess）"></a>CheckRemoteDebuggerPresent（NtQueryInformationProcess）</h2><p><code>CheckRemoteDebuggerPresent</code>不仅可以探测进程自身是否被调试，也可以探测系统其他进程是否被调试。函数接收两个参数进程句柄和一个指向布尔值的指针。如果指定的进程正在被调试，则函数会把指向布尔值的指针设为 TRUE，否则设为FALSE。</p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CheckRemoteDebuggerPresent&#123;<br>HANDLE hProcess,<br>PBOOL pbDebuggerPresent<br>&#125;;<br></code></pre></td></tr></table></figure><p>程序示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-comment">// 定义指针</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">BOOL</span><span class="hljs-params">(WINAPI *CHECK_REMOTE_DEBUG_PROCESS)</span><span class="hljs-params">(HANDLE, PBOOL)</span>;<br><br>BOOL <span class="hljs-title function_">CheckDebugger</span><span class="hljs-params">()</span><br>&#123;<br>    BOOL bDebug = FALSE;<br>    CHECK_REMOTE_DEBUG_PROCESS CheckRemoteDebuggerPresent;<br><br>    HINSTANCE hModule = GetModuleHandle(<span class="hljs-string">&quot;kernel32&quot;</span>);<br>    CheckRemoteDebuggerPresent = (CHECK_REMOTE_DEBUG_PROCESS)GetProcAddress(hModule, <span class="hljs-string">&quot;CheckRemoteDebuggerPresent&quot;</span>);<br><br>    HANDLE hProcess = GetCurrentProcess();<br><br>    CheckRemoteDebuggerPresent(hProcess, &amp;bDebug);<br>    <span class="hljs-keyword">return</span> bDebug;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (CheckDebugger())<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] 进程正在被调试 \n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] 进程没有被调试 \n&quot;</span>);<br>    &#125;<br><br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在《恶意代码分析实战》一书中提到该函数也检测了BeingDebugged标志，而在《加密与解密》中说该函数并没有使用BeingDebugged标志，按照过IsDebuggerPresent的方式再试一次，发现CheckRemoteDebuggerPresent的确没有用到BeingDebugged标志。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311347419.png" alt="image-20231231134736373"></p><p>将BeingDebugged标志位设为00后，程序依旧处于反调试状态。</p><p>那么<code>CheckRemoteDebuggerPresent</code>是通过什么来进行反调试的？</p><p>在xdbg中<strong>Ctrl+G</strong>搜索<code>CheckRemoteDebuggerPresent</code>，可以找到该函数的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">75D131B0 | 8BFF                     | mov edi,edi                             |<br>75D131B2 | 55                       | push ebp                                |<br>75D131B3 | 8BEC                     | mov ebp,esp                             |<br>75D131B5 | 51                       | push ecx                                | ecx:EntryPoint<br>75D131B6 | 837D 08 00               | cmp dword ptr ss:[ebp+8],0              |<br>75D131BA | 56                       | push esi                                | esi:EntryPoint<br>75D131BB | 74 36                    | je kernelbase.75D131F3                  |<br>75D131BD | 8B75 0C                  | mov esi,dword ptr ss:[ebp+C]            | esi:EntryPoint<br>75D131C0 | 85F6                     | test esi,esi                            | esi:EntryPoint<br>75D131C2 | 74 2F                    | je kernelbase.75D131F3                  |<br>75D131C4 | 6A 00                    | push 0                                  |<br>75D131C6 | 6A 04                    | push 4                                  |<br>75D131C8 | 8D45 FC                  | lea eax,dword ptr ss:[ebp-4]            | [ss:[ebp-04]]:BaseThreadInitThunk<br>75D131CB | 50                       | push eax                                |<br>75D131CC | 6A 07                    | push 7                                  |<br>75D131CE | FF75 08                  | push dword ptr ss:[ebp+8]               |<br>75D131D1 | FF15 F0A2D375            | call dword ptr ds:[&lt;NtQueryInformationP |<br>75D131D7 | 85C0                     | test eax,eax                            |<br>75D131D9 | 79 09                    | jns kernelbase.75D131E4                 |<br>75D131DB | 8BC8                     | mov ecx,eax                             | ecx:EntryPoint<br>75D131DD | E8 DEF1F4FF              | call kernelbase.75C623C0                |<br>75D131E2 | EB 17                    | jmp kernelbase.75D131FB                 |<br>75D131E4 | 33C0                     | xor eax,eax                             |<br>75D131E6 | 3945 FC                  | cmp dword ptr ss:[ebp-4],eax            | [dword ptr ss:[ebp-04]]:BaseThreadInitThunk<br>75D131E9 | 0F95C0                   | setne al                                |<br>75D131EC | 8906                     | mov dword ptr ds:[esi],eax              | dword ptr ds:[esi]:EntryPoint<br>75D131EE | 33C0                     | xor eax,eax                             |<br>75D131F0 | 40                       | inc eax                                 |<br>75D131F1 | EB 0A                    | jmp kernelbase.75D131FD                 |<br>75D131F3 | 6A 57                    | push 57                                 |<br>75D131F5 | FF15 C8A0D375            | call dword ptr ds:[&lt;RtlSetLastWin32Erro |<br>75D131FB | 33C0                     | xor eax,eax                             |<br>75D131FD | 5E                       | pop esi                                 | esi:EntryPoint<br>75D131FE | C9                       | leave                                   |<br>75D131FF | C2 0800                  | ret 8                                   |<br></code></pre></td></tr></table></figure><p>其中唯一关键处就是在17行调用了<code>NtQueryInformationProcess</code>函数。</p><p>该函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__kernel_entry NTSTATUS <span class="hljs-title">NtQueryInformationProcess</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            HANDLE           ProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            PROCESSINFOCLASS ProcessInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out]           PVOID            ProcessInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            ULONG            ProcessInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out, optional] PULONG           ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数会根据不同的 <code>ProcessInformationClass</code> 查询有关一个进程对象的信息，在文档中列举了一些情况：</p><table><thead><tr><th>Value</th><th>Meaning</th><th></th></tr></thead><tbody><tr><td><strong>ProcessInformationClass</strong>         0</td><td>搜索指向 PEB 结构的指示器，该结构可用于确定指定进程是否正在调试，以及系统用于标识指定进程的唯一值。使用<a href="https://learn.microsoft.com/en-us/windows/desktop/api/debugapi/nf-debugapi-checkremotedebuggerpresent">CheckRemoteDebuggerPresent</a>和<a href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getprocessid">GetProcessId</a> 函数获取此信息。</td><td></td></tr><tr><td><strong>ProcessDebugPort</strong>                  7</td><td>检索<strong>DWORD_PTR</strong>值，该值是进程的调试器的端口号。非零值表示进程正在环3调试器的控制下运行。使用<a href="https://learn.microsoft.com/en-us/windows/desktop/api/debugapi/nf-debugapi-checkremotedebuggerpresent">CheckRemoteDebuggerPresent</a>或<a href="https://learn.microsoft.com/en-us/windows/desktop/api/debugapi/nf-debugapi-isdebuggerpresent">IsDebuggerPresent</a>函数。</td><td></td></tr><tr><td><strong>ProcessWow64Information</strong>     26</td><td>确定进程是否在 WOW64 环境中运行（WOW64 是允许基于 Win32 的应用程序在 64 位 Windows 上运行的 x86 模拟器）。使用<a href="https://learn.microsoft.com/en-us/windows/desktop/api/wow64apiset/nf-wow64apiset-iswow64process2">IsWow64Process2</a>函数获取此信息。</td><td></td></tr><tr><td><strong>ProcessImageFileName</strong>          27</td><td>搜索包含进程图像文件名称的 <strong>UNICODE_STRING值。</strong>使用<a href="https://learn.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-queryfullprocessimagenamea">QueryFullProcessImageName</a>或<a href="https://learn.microsoft.com/en-us/windows/desktop/api/psapi/nf-psapi-getprocessimagefilenamea">GetProcessImageFileName</a>函数获取此信息。</td><td></td></tr><tr><td><strong>ProcessBreakOnTermination</strong>   29</td><td>搜索<strong>ULONG</strong>值，该值指示进程是否被视为关键进程。<strong>注意</strong> 从 Windows XP SP3 开始可以使用该值。从 Windows 8.1 开始，应改用<a href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-isprocesscritical">IsProcessCritical 。</a></td><td></td></tr><tr><td>**ProcessTelemetryIdInformation **64</td><td>检索包含有关进程的元数据的**<a href="https://learn.microsoft.com/en-us/windows/win32/devnotes/process_telemetry_id_information_type">PROCESS_TELEMETRY_ID_INFORMATION_TYPE值。</a>**</td><td></td></tr><tr><td><strong>ProcessSubsystemInformation</strong>  75</td><td>检索指示进程子系统类型的<strong>SUBSYSTEM_INFORMATION_TYPE值。</strong><em>ProcessInformation</em>参数指向的蜡烛图应该足够大以容纳单个<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/ne-ntddk-_subsystem_information_type">SUBSYSTEM_INFORMATION_TYPE</a>枚举。</td><td></td></tr></tbody></table><p>回到上述汇编，正是查询了7号信息<code>ProcessDebugPort</code>：</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311416990.png" alt="image-20231231141616259"></p><p>所以说，<code>CheckRemoteDebuggerPresent</code>实际上是调用了<code>NtQueryInformationProcess</code>函数，查询了某个进程的<code>ProcessDebugPort</code>，这个值是系统用来与调试器通信的端口句柄。</p><p><strong>如何过掉CheckRemoteDebuggerPresent？</strong></p><p>在IDA中和<code>IsDebuggerPresent</code>都可以采取修改恶意代码的形式，使用xdbg的话，将传给<code>NtQueryInformationProcess</code>的参数7修改掉就可以了。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311425961.png" alt="image-20231231142550898"></p><p>在本例中修改了参数7可以过掉（可能只是个例，因为修改成0，也就是获取进程的基本信息，应该不一定会成功）。还是应该要修改后面的eax寄存器中的值。将01修改成00。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311653922.png" alt="image-20231231165315883"></p><h2 id="OutputDebugString"><a href="#OutputDebugString" class="headerlink" title="OutputDebugString"></a>OutputDebugString</h2><p><code>OutPutDebugString</code>函数的作用是在调试器中显示一个字符串。</p><p>函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutputDebugStringW</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] LPCWSTR lpOutputString</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>如何用它来检测调试状态？</p><p>可以配合<code>SetLastError</code>和 <code>GetLastError</code> 函数，这俩个函数前者将当前的错误码设置成一个任意值，后者是获取当前的错误码。如果进程没有被调试器附加，那么调用<code>OutPutDebugString</code>函数就会失败，错误码会被重新设置，因此再使用<code>GetLastError</code>函数获取的错误码应该就不是我们设置的值。若进程被调试器附加并调用了<code>OutPutDebugString</code>函数，那么该函数会调用成功，<code>GetLastError</code>函数获取的也就是我们设置的值。</p><p>程序示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">CheckDebugger</span><span class="hljs-params">()</span><br>&#123;<br>    DWORD errorValue = <span class="hljs-number">12345</span>;<br>    SetLastError(errorValue);<br><br>    OutputDebugString(<span class="hljs-string">&quot;Test for Debugger&quot;</span>);<br><br>    <span class="hljs-comment">// 检查GetLastError返回的值是否改变</span><br>    <span class="hljs-keyword">if</span> (GetLastError() == errorValue) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] 检测到调试器\n&quot;</span>);<br>        ExitProcess(<span class="hljs-number">1</span>); <span class="hljs-comment">// 结束进程</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] 未检测到调试器\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    CheckDebugger();<br>    <span class="hljs-comment">// 这里可以添加其他代码</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述程序是由《恶意代码实战分析》的代码清单扩展来的，但实际发现，没有附加调试器的情况下，也会报<strong>“[-] 检测到调试器”</strong>。原因应该是因为：程序没有调用<code>OutPutDebugString</code>函数也会改变错误码。</p><h2 id="ZwSetInformationThread（ThreadHideFromDebugger）"><a href="#ZwSetInformationThread（ThreadHideFromDebugger）" class="headerlink" title="ZwSetInformationThread（ThreadHideFromDebugger）"></a>ZwSetInformationThread（ThreadHideFromDebugger）</h2><p>一种调试器攻击。</p><p><code>ZwSetInformationThread</code>函数，用于设置线程的优先级。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSYSAPI NTSTATUS <span class="hljs-title">ZwSetInformationThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] HANDLE          ThreadHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] THREADINFOCLASS ThreadInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] PVOID           ThreadInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] ULONG           ThreadInformationLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数可以设置一个与线程相关的信息。查看<code>ThreadInformationClass</code>列表：<br><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311703401.png" alt="image-20231231170307307"></p><p>可以看到<code>ThreadHideFromDebugger</code>，关于它的定义：<br>这个信息类只能被设置。它禁用了线程的调试事件生成。这个信息类不需要数据，因此 <code>ThreadInformation</code> 可以是一个空指针。<code>ThreadInformationLength</code> 应该是零。</p><p>通过为线程设置<code>ThreadHideFromDebugger</code>，可以禁止某个线程产生调试事件。</p><p>测试示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-comment">// #include &lt;winternl.h&gt; // 包含 NTSTATUS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 确保 NTSTATUS 已定义。如果没有，手动定义它。</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NTSTATUS</span><br><span class="hljs-keyword">typedef</span> LONG NTSTATUS;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 定义 ZwSetInformationThread 函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span> <span class="hljs-params">(WINAPI *ZW_SET_INFORMATION_THREAD)</span><span class="hljs-params">(HANDLE, DWORD, PVOID, ULONG)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ThreadHideFromDebugger 0x11 <span class="hljs-comment">// 17 in decimal</span></span><br><br><span class="hljs-comment">// 函数来禁用调试事件</span><br><span class="hljs-function">VOID <span class="hljs-title">DisableDebugEvent</span><span class="hljs-params">(VOID)</span></span><br><span class="hljs-function"></span>&#123;<br>    HMODULE hModule;<br>    ZW_SET_INFORMATION_THREAD ZwSetInformationThread;<br><br>    <span class="hljs-comment">// 获取 ntdll.dll 模块的句柄</span><br>    hModule = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;Ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (hModule == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法获取 ntdll.dll 的句柄.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取 ZwSetInformationThread 函数的地址</span><br>    ZwSetInformationThread = (ZW_SET_INFORMATION_THREAD)<span class="hljs-built_in">GetProcAddress</span>(hModule, <span class="hljs-string">&quot;ZwSetInformationThread&quot;</span>);<br>    <span class="hljs-keyword">if</span> (ZwSetInformationThread == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法获取 ZwSetInformationThread 函数的地址.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 调用函数尝试隐藏当前线程</span><br>    NTSTATUS status = <span class="hljs-built_in">ZwSetInformationThread</span>(<span class="hljs-built_in">GetCurrentThread</span>(), ThreadHideFromDebugger, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (status != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;调用 ZwSetInformationThread 失败，状态码: 0x%X\n&quot;</span>, status);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前线程已尝试隐藏自调试器.\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;测试程序开始...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 尝试禁用调试事件</span><br>    <span class="hljs-built_in">DisableDebugEvent</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.....&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我用单步测试的，在打印“当前线程已尝试隐藏自调试器.”之后延迟一会程序就会退出调试状态。</p><p><strong>关于怎么干掉这个反调试。（待学）</strong><a href="https://bbs.kanxue.com/thread-249689.html">https://bbs.kanxue.com/thread-249689.html</a></p><h1 id="手动检测数据结构"><a href="#手动检测数据结构" class="headerlink" title="手动检测数据结构"></a>手动检测数据结构</h1><p>在一些情况下，程序中可能没有使用Windows API进行反调试，所以需要我们手动检查数据结构，关注一些会暴露调试器的数据结构（PEB）。</p><h2 id="检测BeingDebugged属性"><a href="#检测BeingDebugged属性" class="headerlink" title="检测BeingDebugged属性"></a>检测BeingDebugged属性</h2><p><code>BeingDebugged</code>如上文所说，位于PEB中的<strong>0x2偏移处</strong>；</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311603285.png" alt="image-20231231160314219"></p><p>过掉这种调试的方法就是在执行跳转是，手动修改零标志（使其强制跳转或不跳转）；或者修改跳转指令；手动设置BeingDebugged属性值为0；</p><h2 id="检测ProcessHeap属性"><a href="#检测ProcessHeap属性" class="headerlink" title="检测ProcessHeap属性"></a>检测ProcessHeap属性</h2><p>在PEB结构的Reserved4数组中有一个未公开的位置叫做<code>ProcessHeap</code>，它被设置为加载器为进程分配的第一个堆的位置。ProcessHeap位于PEB结构的<strong>0x18偏移处</strong>。第一个堆头部有一个属性字段，它告诉内核这个堆是否在调试器中创建。这些属性叫做<code>ForceFlags</code>和<code>Flags</code>。</p><p>在正常情况下，系统在为进程创建第一个堆时，会将它的Flags和ForceFlags分别设为<strong>2和0</strong>，而在调试状态下，这俩个标志通常会被设为50000062h（取决于NtGlobalFlag）和40000060h。</p><p>同时，<code>Flags</code>位于ProcessHeap的<strong>0x0c偏移处</strong>，<code>ForceFlags</code>位于ProcessHeap的<strong>0x10偏移处</strong>。</p><p>因此可以写出这样一段检测代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,fs:[0x30];获取PEB<br>mov eax,[eax+0x18];获取ProcessHeap<br>cmp dword ptr [eax+0x0C],2;获取Flags<br>jne __debugger_detected<br>cmp dword ptr [eax+0x10],0;获取ForceFlags<br>jne __debugger_detected<br></code></pre></td></tr></table></figure><p>对付这种反调试的方法之一就是手动修改ProcessHeap标志。</p><h2 id="检测NtGlobalFlag"><a href="#检测NtGlobalFlag" class="headerlink" title="检测NtGlobalFlag"></a>检测NtGlobalFlag</h2><p><code>NtGlobalFlag</code>位于PEB结构的<strong>0x68偏移处</strong>。因为在调试器中启动进程和正常模式下启动进程时它们创建内存堆的方式不同。如果进程是由调试器创建的，那么该标志的值会被设置成<strong>0x70</strong>。</p><p>检测代码：</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311631499.png" alt="image-20231231163106456"></p><p>过掉反调试的方法都差不多。</p><h1 id="识别调试器行为"><a href="#识别调试器行为" class="headerlink" title="识别调试器行为"></a>识别调试器行为</h1><p>在逆向工程中，进行代码分析时，可以用调试器设置断点，或者单步执行一个进程。当调试器在执行这些操作时，它们会<strong>修改</strong>进程中的代码。因此，恶意代码常使用探测<strong>INT扫描</strong>、<strong>完整性校验</strong>，以及<strong>时钟检测</strong>等几种类型的调试器行为。</p><h2 id="断点检测"><a href="#断点检测" class="headerlink" title="断点检测"></a>断点检测</h2><h3 id="软件断点"><a href="#软件断点" class="headerlink" title="软件断点"></a>软件断点</h3><p>原理：调试器在设置断点时的一般采用的是<strong>软件断点（INT 3）</strong>，打下INT 3后调试器会临时替换运行程序中的一条指令，当程序运行到这里时，调用<strong>调试异常处理例程</strong>。</p><p>INT 3 的机器码是<strong>0xCC</strong>，所以若是在关键位置检测到该指令，就可以判断进程处于调试状态。。</p><p>常用的反调试方法，扫描0xCC。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call $+5<br>pop edi <br>sub edi, 5<br>mov ecx, 400h<br>mov eax, 0CCh<br>repne scasb<br>jz DebuggerDetected<br></code></pre></td></tr></table></figure><p>这段先执行了一个函数调用，随后用pop指令将eip寄存器的值存入edi，然后将edi设置为代码的开始。接下来扫描这段代码的0xCC字节，如果发现0xCC则证明存在调试器。</p><p>对抗这种反调试技术的方法就是<strong>使用硬件断点</strong>。</p><p>示例程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取MessageBoxA函数地址</span><br>    FARPROC addr = <span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">LoadLibraryW</span>(<span class="hljs-string">L&quot;user32.dll&quot;</span>), <span class="hljs-string">&quot;MessageBoxA&quot;</span>);<br>    <br>    <span class="hljs-comment">// 读取函数入口处的第一个字节</span><br>    BYTE byteAtAddr = *(BYTE*)addr;<br>    <br>    <span class="hljs-comment">// 显示消息框作为正常功能的一部分</span><br>    <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;context&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>, MB_OK);<br><br>    <span class="hljs-comment">// 检查是否为0xCC（INT 3指令）</span><br>    <span class="hljs-keyword">if</span> (byteAtAddr == <span class="hljs-number">0xCC</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;检测到调试&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;无调试&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>用xdbg调试，<strong>Ctrl+G</strong>搜索<code>MessageBoxA</code>。在函数处下断点，之后一直单步就可以发现程序输出了检测到调试。</p><p>查看汇编代码：</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011026505.png" alt="image-20240101102602420"></p><p>在调用完函数后，调试器扫描了esp-10处开始的字节，查找0xCC。</p><p>对抗：</p><p>在xdbg右键断点设置硬件断点，</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011029692.png" alt="image-20240101102927639"></p><p>再次调试发现，变成了无调试。成功过掉。（</p><h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><p>先了解一下什么是<strong>硬件断点</strong>，硬件断点和<strong>DRx寄存器</strong>有关，下图是Intel CPU体系架构里对DRx寄存器的介绍。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011137550.png" alt="image-20240101113735452"></p><ul><li>DR0~DR3就好，这四个位置一般用于设置硬件断点。</li><li>DR4和DR5保留，并未公开。</li><li>DR6是调试寄存器组状态寄存器。</li><li>DR7是调试寄存器组控制寄存器。</li></ul><p>硬件断点的原理是使用<strong>DR0~DR3设定地址</strong>，并使用DR7设定状态，因此最多设置<strong>4</strong>个断点。</p><p><strong>怎么实现硬件断点反调试？</strong></p><p>先获取硬件断点信息，利用函数<code>GetThreadContext</code>，它检索指定线程的上下文。</p><p>函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">GetThreadContext</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]      HANDLE    hThread,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, out] LPCONTEXT lpContext</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>第一个参数是要检索其上下文线程的<strong>句柄</strong>，第二个参数指向<strong>CONTEXT结构</strong>。该结构是一个在Windows API中定义的结构体，它用于存储线程的上下文信息，包括<strong>寄存器</strong>和其他重要的状态信息。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011159462.png" alt="image-20240101115917410"></p><p>因此我们需要获取CONTEXT结构体中的DRx寄存器的信息，使用<code>CONTEXT_DEBUG_REFGISTERS</code>标志。</p><p>示例程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CONTEXT TestContext;<br>    <span class="hljs-built_in">ZeroMemory</span>(&amp;TestContext, <span class="hljs-built_in">sizeof</span>(CONTEXT)); <span class="hljs-comment">// 将结构体清零</span><br>    TestContext.ContextFlags = CONTEXT_DEBUG_REGISTERS;<br>    <br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetThreadContext</span>(<span class="hljs-built_in">GetCurrentThread</span>(), &amp;TestContext)) &#123;<br>        <span class="hljs-keyword">if</span> (TestContext.Dr0 != <span class="hljs-number">0</span> || TestContext.Dr1 != <span class="hljs-number">0</span> || <br>            TestContext.Dr2 != <span class="hljs-number">0</span> || TestContext.Dr3 != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;硬件断点检测成功, 程序正在被调试！&quot;</span>, <span class="hljs-string">&quot;硬件断点检测&quot;</span>, MB_OK);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;没有检测到硬件断点。&quot;</span>, <span class="hljs-string">&quot;硬件断点检测&quot;</span>, MB_OK);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        DWORD dwError = <span class="hljs-built_in">GetLastError</span>();<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;GetThreadContext failed with error: &quot;</span> &lt;&lt; dwError &lt;&lt; std::endl;<br>        <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;无法获取线程上下文信息。&quot;</span>, <span class="hljs-string">&quot;错误&quot;</span>, MB_OK);<br>    &#125;<br>    <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>); <span class="hljs-comment">// 使用cin.get()或std::getchar()可能是一个更好的选择</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行调试</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011202255.png" alt="image-20240101120236208"></p><p>随便下个硬件断点，检测成功。</p><p><strong>采用异常来进行硬件断点反调试</strong>（待学）<a href="https://www.cnblogs.com/Sna1lGo/p/15358626.html">https://www.cnblogs.com/Sna1lGo/p/15358626.html</a></p><h2 id="执行代码校验和检查"><a href="#执行代码校验和检查" class="headerlink" title="执行代码校验和检查"></a>执行代码校验和检查</h2><p>恶意代码可以计算代码段的校验并实现与扫描中断相同的目的。与扫描0xCC不同，这种检查仅执行恶意代码中机器码的<strong>CRC（循环冗余校验）</strong>或<strong>MD5校验</strong>和检查。</p><p>下面是一个简单的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function">BOOL <span class="hljs-title">CheckIntegrity</span><span class="hljs-params">()</span> </span>&#123;<br>    PIMAGE_DOS_HEADER pDosHeader;<br>    PIMAGE_NT_HEADERS pNtHeaders;<br>    PIMAGE_SECTION_HEADER pSectionHeader;<br>    DWORD dwBaseImage = (DWORD)<span class="hljs-built_in">GetModuleHandle</span>(<span class="hljs-literal">NULL</span>);<br>    <br>    pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage;<br>    pNtHeaders = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);<br>    pSectionHeader = <span class="hljs-built_in">IMAGE_FIRST_SECTION</span>(pNtHeaders);<br>    <br>    DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage;<br>    DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData;<br>    <br>    DWORD checksum = <span class="hljs-number">0</span>;<br>    BYTE* code = <span class="hljs-built_in">reinterpret_cast</span>&lt;BYTE*&gt;(dwAddr);<br>    <br>    <span class="hljs-keyword">for</span> (DWORD i = <span class="hljs-number">0</span>; i &lt; dwCodeSize; ++i) &#123;<br>        checksum += code[i];<br>        checksum = (checksum &gt;&gt; <span class="hljs-number">31</span>) | (checksum &lt;&lt; <span class="hljs-number">1</span>); <span class="hljs-comment">// ROL checksum, 1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (checksum != <span class="hljs-number">0x46ea24</span>) &#123;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CheckIntegrity</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Integrity check passed.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Integrity check failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个程序中，<code>checksum</code>变量计算为代码段中所有字节的累加和，并对每个字节累加后进行一次ROL。然后将这个 <code>checksum</code> 和一个预设的校验和值比较。</p><p>关于绕过，可以修改检查函数或者校验和值。</p><h2 id="时钟检测"><a href="#时钟检测" class="headerlink" title="时钟检测"></a>时钟检测</h2><p>程序调试时，进程的运行速度大大降低（单步调试）。</p><p>有如下俩种用时钟检测来探测调试器存在的方法：</p><ul><li>记录执行一段操作前后的时间戳，然后比较这俩个时间戳，如果存在滞后，则可以认为存在调试器。</li><li>记录一个异常前后的时间戳。如果不调试进程，可以很快处理完异常，因为调试器处理异常的速度非常慢。因此默认情况下，调试器处理异常需要人为干预，这导致大量延迟。</li></ul><h3 id="rdstc指令"><a href="#rdstc指令" class="headerlink" title="rdstc指令"></a>rdstc指令</h3><p>rdtsc指令（操作码0x0F31）用于获取CPU自开机运行起的时钟周期数，并且将其作为一个64位的值存入edx和eax寄存器中。执行俩次rdstc指令，然后比较这俩次取值之间的差值</p><p>汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">rdtsc<br>mov ecx, eax<br>mov ebx, edx<br>;计算俩个rdtsc的偏移量<br>rdtsc<br>cmp edx, ebx<br>ja __debugger_found<br>sub eax, ecx<br>cmp eax, 0x200<br>ja __debugger_found<br></code></pre></td></tr></table></figure><p>俩次调用rdtsc,先检查了高位edx相不相同，相同的话再检查低位的差值是否大于0x20。</p><h3 id="QueryPerformanceCounter或GetTickCount"><a href="#QueryPerformanceCounter或GetTickCount" class="headerlink" title="QueryPerformanceCounter或GetTickCount"></a>QueryPerformanceCounter或GetTickCount</h3><p><code>QueryPerformanceCounter</code>函数检索性能计数器的当前值，这是一个高分辨率 (&lt;1us) 时间戳，可用于时间间隔度量。</p><p><code>GetTickCount</code>检索自系统启动以来经过的毫秒数。</p><p>这俩个函数都可以用于时钟检测。</p><p>下面是一个GetTickCount的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function">BOOL <span class="hljs-title">IsDebuggerPresentWithTiming</span><span class="hljs-params">()</span></span>&#123;<br>    DWORD startTick,endTick,elapsed;<br>    <br>    <span class="hljs-comment">// 获取初始的 tick 计数</span><br>    startTick = <span class="hljs-built_in">GetTickCount</span>();<br><br>    <span class="hljs-comment">// 此处可以添加代码</span><br>    <span class="hljs-built_in">OutputDebugString</span>(<span class="hljs-string">&quot;Debugger check...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 获取结束的 tick 计数</span><br>    endTick = <span class="hljs-built_in">GetTickCount</span>();<br><br>    <span class="hljs-comment">// 计算经过的 tick 数</span><br>    elapsed = endTick - startTick;<br><br>    <span class="hljs-comment">// 如果时间差超出预设值，则可能存在调试器。</span><br>    <span class="hljs-keyword">if</span> (elapsed &gt; <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">return</span> TRUE;<br>    &#125;<br>    <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsDebuggerPresentWithTiming</span>())&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;可能检测到调试器！&quot;</span> &lt;&lt;std::endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;没有检测到调试器！&quot;</span> &lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>过掉时钟检测比较好的办法是在检测指令之后下断点。例如：</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011113952.png" alt="image-20240101111332854"></p><h2 id="父进程检测"><a href="#父进程检测" class="headerlink" title="父进程检测"></a>父进程检测</h2><p>从理论上讲，一个程序被正常启动时，其父进程应该是<strong>Exploer.exe(资源管理器启动)<strong>、</strong>cmd.exe（命令行启动）</strong>或者<strong>Services.exe（系统服务）</strong>中的一个。如果某一个进程的父进程并非上述3个进程之一，一遍可以认为它被调试了（或者被内存补丁之类的Loader程序加载了）。</p><p>实现这种检测的方法：</p><ol><li>通过TEB（TEB.ClientId）或者GetCurrentProcessId来检索当前进程的PID。</li><li>通过Process32First、Process32Next得到所有进程的列表，判断explorer.exe的PID（通过PROCESSENTERY.szExeFile）和通过PROCESSENTRy.th32ParentProcessID获得的当前进程的父进程ID是否相同。</li><li>如果父进程的PID不是上述三种的其中之一，那么目标进程很可能被调试了。</li></ol><h1 id="干扰调试器的功能"><a href="#干扰调试器的功能" class="headerlink" title="干扰调试器的功能"></a>干扰调试器的功能</h1><h2 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h2><p><strong>Thread Local Storage(TLS)，即线程本地存储</strong>，是Windows为解决一个进程中多个线程同时访问全局变量而提供的机制。</p><p>TLS回调函数就是在程序加载到调试器后，TLS回调会<strong>先于</strong>程序入口执行之前运行代码，这样就可以提前进行反调试操作或者修改代码。</p><p>在IDA中可以使用 <code>Ctrl + E</code> 查看二进制的入口点。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011210653.png" alt="image-20240101121030613"></p><p>在PEview等PE工具中也可以查看.tls段，因为通常情况下，正常程序不使用.tls段。</p><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011211398.png" alt="image-20240101121149354"></p><h2 id="使用异常×"><a href="#使用异常×" class="headerlink" title="使用异常×"></a>使用异常×</h2><p>（待学）。。。</p><h2 id="插入中断"><a href="#插入中断" class="headerlink" title="插入中断"></a>插入中断</h2><h3 id="插入INT-3"><a href="#插入INT-3" class="headerlink" title="插入INT 3"></a>插入INT 3</h3><p>调试器使用 INT 3设置软件断点，所以一种反调试技术就是在合法代码中插入0xCC来欺骗调试器，使其认为这些0xCC机器码是自己设置的段带你。</p><p>一些调试器用跟踪自身设置的断点的方法来避免这种反调试技术。</p><h3 id="插入INT-2D断点×"><a href="#插入INT-2D断点×" class="headerlink" title="插入INT 2D断点×"></a>插入INT 2D断点×</h3><h3 id="插入ICE断点×"><a href="#插入ICE断点×" class="headerlink" title="插入ICE断点×"></a>插入ICE断点×</h3><p>嗯。待学（INT 2D。ICE是什么。）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/02/hello-world/"/>
    <url>/2024/04/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
