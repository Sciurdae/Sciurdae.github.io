

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/sunsun.png">
  <link rel="icon" href="/img/sunsun.png">
  <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="referrer" content="no-referrer"/>
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#f4cccc">
  <meta name="author" content="Sciurdae">
  <meta name="keywords" content="">
  
    <meta name="description" content="Windows反调试技术学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows反调试技术">
<meta property="og:url" content="http://sciurdae.online/2024/04/02/Windows%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="Sciurdae&#39;s 小窝">
<meta property="og:description" content="Windows反调试技术学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311337977.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311334489.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311335298.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311347419.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311416990.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311425961.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311653922.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311703401.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311603285.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311631499.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011026505.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011029692.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011137550.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011159462.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011202255.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011113952.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011210653.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011211398.png">
<meta property="article:published_time" content="2024-04-02T12:23:15.885Z">
<meta property="article:modified_time" content="2024-04-03T01:35:31.906Z">
<meta property="article:author" content="Sciurdae">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311337977.png">
  
  
  
  <title>Windows反调试技术 - Sciurdae&#39;s 小窝</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/css/decorate.css">
<link rel="stylesheet" href="/css/customm.css">
<link rel="stylesheet" href="/css/cloudedGlass.css">
<link rel="stylesheet" href="/css/scrollAnimation.css">
<link rel="stylesheet" href="/css/selection.css">
<link rel="stylesheet" href="/css/macBorder.css">
<link rel="stylesheet" href="/css/scrollbar.css">
<link rel="stylesheet" href="/css/font-custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"sciurdae.online","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"SRfFH0K09R040yFG7bfIbwPN-MdYXbMMI","app_key":"ipbxy4I7kbGQTwmWce2SnvyU","server_url":null,"path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.1.1"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Sciurdae&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/guestbook/" target="_self">
                <i class="iconfont icon-comment-fill"></i>
                <span>guestbook</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/sun.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Windows反调试技术</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-02 20:23" pubdate>
          2024年4月2日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          49 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          阅读次数 <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Windows反调试技术</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2024年4月3日 上午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>Windows反调试技术学习笔记</p>
<span id="more"></span>


<h1 id="Windows反调试"><a href="#Windows反调试" class="headerlink" title="Windows反调试"></a><strong>Windows反调试</strong></h1><h1 id="通过-API-调用"><a href="#通过-API-调用" class="headerlink" title="通过 API 调用"></a>通过 API 调用</h1><h2 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent"></a>IsDebuggerPresent</h2><p><code>IsDebuggerPresent</code>函数通过获取进程环境块（PEB）中的<code>BeingDebugged</code>标志来检测进程是否处于调试状态。</p>
<p>其实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">IsDebuggerPresent</span><span class="hljs-params">(VOID)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> NtCurrentPeb() -&gt; BeingDebugged;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>BeingDebugged是PEB中的一个标志。每个运行中的进程都有一个PEB结构，其<strong>0x02偏移处</strong>就是BeingDebugged标志，如果程序处于调试状态，该标志的值会被设置为<strong>非零值</strong>。相关Windows API就是通过访问该值来进行反调试操作。</p>
<p>如何访问PEB？PEB的地址储存在另一个名为线程环境块（TEB）中。</p>
<p>Windows在调入进程、创建线程时，操作系统会为每个线程分配TEB，而且FS段寄存器总是被设置成使得<code>FS:[0]</code>指向当前线程的TEB数据。而TEB结构中的<strong>0x30偏移处</strong>正是PEB的地址。</p>
<p>Windows一般通过TEB间接获取PEB的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,fs:[18h]		//获取当前线程的TEB地址<br>mov eax,[eax+30h]		//在TEB偏移30h处获得PEB地址<br></code></pre></td></tr></table></figure>

<p>TIB+18h处为Self。它是TIB的自身指针，指向TEB的首地址。因此也可以省略它直接使用<code>fs:[30h]</code>得到自己进程的PEB。</p>
<p>如何过掉IsDebuggerPresent？</p>
<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br>BOOL <span class="hljs-title function_">CheckDebugger</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 直接调用IsDebuggerPresent函数，不需要定义额外的指针</span><br>    <span class="hljs-keyword">return</span> IsDebuggerPresent();<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (CheckDebugger())<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] 进程正在被调试 \n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] 进程没有被调试 \n&quot;</span>);<br>    &#125;<br><br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一种方法是IDA中在<strong>修改恶意代码</strong>（例如jz跳转将其改为jnz，或者修改cmp）</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311337977.png" srcset="/img/loading.gif" lazyload alt="image-20231231133724934"></p>
<p>第二种使用xdbg，在数据窗口使用“Ctrl+G”搜索<strong>fs:[30]+2</strong>；</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311334489.png" srcset="/img/loading.gif" lazyload alt="image-20231231133408373"></p>
<p>这里的01就是BeingDebugged标志，将其用“Ctrl+E”修改成00，运行程序，程序输出：</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311335298.png" srcset="/img/loading.gif" lazyload alt="image-20231231133520252"></p>
<h2 id="CheckRemoteDebuggerPresent（NtQueryInformationProcess）"><a href="#CheckRemoteDebuggerPresent（NtQueryInformationProcess）" class="headerlink" title="CheckRemoteDebuggerPresent（NtQueryInformationProcess）"></a>CheckRemoteDebuggerPresent（NtQueryInformationProcess）</h2><p><code>CheckRemoteDebuggerPresent</code>不仅可以探测进程自身是否被调试，也可以探测系统其他进程是否被调试。函数接收两个参数进程句柄和一个指向布尔值的指针。如果指定的进程正在被调试，则函数会把指向布尔值的指针设为 TRUE，否则设为FALSE。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CheckRemoteDebuggerPresent&#123;<br>	HANDLE hProcess,<br>	PBOOL pbDebuggerPresent<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>程序示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-comment">// 定义指针</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">BOOL</span><span class="hljs-params">(WINAPI *CHECK_REMOTE_DEBUG_PROCESS)</span><span class="hljs-params">(HANDLE, PBOOL)</span>;<br><br>BOOL <span class="hljs-title function_">CheckDebugger</span><span class="hljs-params">()</span><br>&#123;<br>    BOOL bDebug = FALSE;<br>    CHECK_REMOTE_DEBUG_PROCESS CheckRemoteDebuggerPresent;<br><br>    HINSTANCE hModule = GetModuleHandle(<span class="hljs-string">&quot;kernel32&quot;</span>);<br>    CheckRemoteDebuggerPresent = (CHECK_REMOTE_DEBUG_PROCESS)GetProcAddress(hModule, <span class="hljs-string">&quot;CheckRemoteDebuggerPresent&quot;</span>);<br><br>    HANDLE hProcess = GetCurrentProcess();<br><br>    CheckRemoteDebuggerPresent(hProcess, &amp;bDebug);<br>    <span class="hljs-keyword">return</span> bDebug;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (CheckDebugger())<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] 进程正在被调试 \n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] 进程没有被调试 \n&quot;</span>);<br>    &#125;<br><br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在《恶意代码分析实战》一书中提到该函数也检测了BeingDebugged标志，而在《加密与解密》中说该函数并没有使用BeingDebugged标志，按照过IsDebuggerPresent的方式再试一次，发现CheckRemoteDebuggerPresent的确没有用到BeingDebugged标志。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311347419.png" srcset="/img/loading.gif" lazyload alt="image-20231231134736373"></p>
<p>将BeingDebugged标志位设为00后，程序依旧处于反调试状态。</p>
<p>那么<code>CheckRemoteDebuggerPresent</code>是通过什么来进行反调试的？</p>
<p>在xdbg中<strong>Ctrl+G</strong>搜索<code>CheckRemoteDebuggerPresent</code>，可以找到该函数的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">75D131B0 | 8BFF                     | mov edi,edi                             |<br>75D131B2 | 55                       | push ebp                                |<br>75D131B3 | 8BEC                     | mov ebp,esp                             |<br>75D131B5 | 51                       | push ecx                                | ecx:EntryPoint<br>75D131B6 | 837D 08 00               | cmp dword ptr ss:[ebp+8],0              |<br>75D131BA | 56                       | push esi                                | esi:EntryPoint<br>75D131BB | 74 36                    | je kernelbase.75D131F3                  |<br>75D131BD | 8B75 0C                  | mov esi,dword ptr ss:[ebp+C]            | esi:EntryPoint<br>75D131C0 | 85F6                     | test esi,esi                            | esi:EntryPoint<br>75D131C2 | 74 2F                    | je kernelbase.75D131F3                  |<br>75D131C4 | 6A 00                    | push 0                                  |<br>75D131C6 | 6A 04                    | push 4                                  |<br>75D131C8 | 8D45 FC                  | lea eax,dword ptr ss:[ebp-4]            | [ss:[ebp-04]]:BaseThreadInitThunk<br>75D131CB | 50                       | push eax                                |<br>75D131CC | 6A 07                    | push 7                                  |<br>75D131CE | FF75 08                  | push dword ptr ss:[ebp+8]               |<br>75D131D1 | FF15 F0A2D375            | call dword ptr ds:[&lt;NtQueryInformationP |<br>75D131D7 | 85C0                     | test eax,eax                            |<br>75D131D9 | 79 09                    | jns kernelbase.75D131E4                 |<br>75D131DB | 8BC8                     | mov ecx,eax                             | ecx:EntryPoint<br>75D131DD | E8 DEF1F4FF              | call kernelbase.75C623C0                |<br>75D131E2 | EB 17                    | jmp kernelbase.75D131FB                 |<br>75D131E4 | 33C0                     | xor eax,eax                             |<br>75D131E6 | 3945 FC                  | cmp dword ptr ss:[ebp-4],eax            | [dword ptr ss:[ebp-04]]:BaseThreadInitThunk<br>75D131E9 | 0F95C0                   | setne al                                |<br>75D131EC | 8906                     | mov dword ptr ds:[esi],eax              | dword ptr ds:[esi]:EntryPoint<br>75D131EE | 33C0                     | xor eax,eax                             |<br>75D131F0 | 40                       | inc eax                                 |<br>75D131F1 | EB 0A                    | jmp kernelbase.75D131FD                 |<br>75D131F3 | 6A 57                    | push 57                                 |<br>75D131F5 | FF15 C8A0D375            | call dword ptr ds:[&lt;RtlSetLastWin32Erro |<br>75D131FB | 33C0                     | xor eax,eax                             |<br>75D131FD | 5E                       | pop esi                                 | esi:EntryPoint<br>75D131FE | C9                       | leave                                   |<br>75D131FF | C2 0800                  | ret 8                                   |<br></code></pre></td></tr></table></figure>

<p>其中唯一关键处就是在17行调用了<code>NtQueryInformationProcess</code>函数。</p>
<p>该函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__kernel_entry NTSTATUS <span class="hljs-title">NtQueryInformationProcess</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            HANDLE           ProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            PROCESSINFOCLASS ProcessInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out]           PVOID            ProcessInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            ULONG            ProcessInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out, optional] PULONG           ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>该函数会根据不同的 <code>ProcessInformationClass</code> 查询有关一个进程对象的信息，在文档中列举了一些情况：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ProcessInformationClass</strong>         0</td>
<td>搜索指向 PEB 结构的指示器，该结构可用于确定指定进程是否正在调试，以及系统用于标识指定进程的唯一值。使用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/debugapi/nf-debugapi-checkremotedebuggerpresent">CheckRemoteDebuggerPresent</a>和<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getprocessid">GetProcessId</a> 函数获取此信息。</td>
<td></td>
</tr>
<tr>
<td><strong>ProcessDebugPort</strong>                  7</td>
<td>检索<strong>DWORD_PTR</strong>值，该值是进程的调试器的端口号。非零值表示进程正在环3调试器的控制下运行。使用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/debugapi/nf-debugapi-checkremotedebuggerpresent">CheckRemoteDebuggerPresent</a>或<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/debugapi/nf-debugapi-isdebuggerpresent">IsDebuggerPresent</a>函数。</td>
<td></td>
</tr>
<tr>
<td><strong>ProcessWow64Information</strong>     26</td>
<td>确定进程是否在 WOW64 环境中运行（WOW64 是允许基于 Win32 的应用程序在 64 位 Windows 上运行的 x86 模拟器）。使用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/wow64apiset/nf-wow64apiset-iswow64process2">IsWow64Process2</a>函数获取此信息。</td>
<td></td>
</tr>
<tr>
<td><strong>ProcessImageFileName</strong>          27</td>
<td>搜索包含进程图像文件名称的 <strong>UNICODE_STRING值。</strong>使用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-queryfullprocessimagenamea">QueryFullProcessImageName</a>或<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/psapi/nf-psapi-getprocessimagefilenamea">GetProcessImageFileName</a>函数获取此信息。</td>
<td></td>
</tr>
<tr>
<td><strong>ProcessBreakOnTermination</strong>   29</td>
<td>搜索<strong>ULONG</strong>值，该值指示进程是否被视为关键进程。<strong>注意</strong> 从 Windows XP SP3 开始可以使用该值。从 Windows 8.1 开始，应改用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-isprocesscritical">IsProcessCritical 。</a></td>
<td></td>
</tr>
<tr>
<td>**ProcessTelemetryIdInformation **64</td>
<td>检索包含有关进程的元数据的**<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/devnotes/process_telemetry_id_information_type">PROCESS_TELEMETRY_ID_INFORMATION_TYPE值。</a>**</td>
<td></td>
</tr>
<tr>
<td><strong>ProcessSubsystemInformation</strong>  75</td>
<td>检索指示进程子系统类型的<strong>SUBSYSTEM_INFORMATION_TYPE值。</strong><em>ProcessInformation</em>参数指向的蜡烛图应该足够大以容纳单个<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/ne-ntddk-_subsystem_information_type">SUBSYSTEM_INFORMATION_TYPE</a>枚举。</td>
<td></td>
</tr>
</tbody></table>
<p>回到上述汇编，正是查询了7号信息<code>ProcessDebugPort</code>：</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311416990.png" srcset="/img/loading.gif" lazyload alt="image-20231231141616259"></p>
<p>所以说，<code>CheckRemoteDebuggerPresent</code>实际上是调用了<code>NtQueryInformationProcess</code>函数，查询了某个进程的<code>ProcessDebugPort</code>，这个值是系统用来与调试器通信的端口句柄。</p>
<p><strong>如何过掉CheckRemoteDebuggerPresent？</strong></p>
<p>在IDA中和<code>IsDebuggerPresent</code>都可以采取修改恶意代码的形式，使用xdbg的话，将传给<code>NtQueryInformationProcess</code>的参数7修改掉就可以了。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311425961.png" srcset="/img/loading.gif" lazyload alt="image-20231231142550898"></p>
<p>在本例中修改了参数7可以过掉（可能只是个例，因为修改成0，也就是获取进程的基本信息，应该不一定会成功）。还是应该要修改后面的eax寄存器中的值。将01修改成00。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311653922.png" srcset="/img/loading.gif" lazyload alt="image-20231231165315883"></p>
<h2 id="OutputDebugString"><a href="#OutputDebugString" class="headerlink" title="OutputDebugString"></a>OutputDebugString</h2><p><code>OutPutDebugString</code>函数的作用是在调试器中显示一个字符串。</p>
<p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutputDebugStringW</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] LPCWSTR lpOutputString</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>如何用它来检测调试状态？</p>
<p>可以配合<code>SetLastError</code>和 <code>GetLastError</code> 函数，这俩个函数前者将当前的错误码设置成一个任意值，后者是获取当前的错误码。如果进程没有被调试器附加，那么调用<code>OutPutDebugString</code>函数就会失败，错误码会被重新设置，因此再使用<code>GetLastError</code>函数获取的错误码应该就不是我们设置的值。若进程被调试器附加并调用了<code>OutPutDebugString</code>函数，那么该函数会调用成功，<code>GetLastError</code>函数获取的也就是我们设置的值。</p>
<p>程序示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">CheckDebugger</span><span class="hljs-params">()</span><br>&#123;<br>    DWORD errorValue = <span class="hljs-number">12345</span>;<br>    SetLastError(errorValue);<br><br>    OutputDebugString(<span class="hljs-string">&quot;Test for Debugger&quot;</span>);<br><br>    <span class="hljs-comment">// 检查GetLastError返回的值是否改变</span><br>    <span class="hljs-keyword">if</span> (GetLastError() == errorValue) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] 检测到调试器\n&quot;</span>);<br>        ExitProcess(<span class="hljs-number">1</span>); <span class="hljs-comment">// 结束进程</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] 未检测到调试器\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    CheckDebugger();<br>    <span class="hljs-comment">// 这里可以添加其他代码</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上述程序是由《恶意代码实战分析》的代码清单扩展来的，但实际发现，没有附加调试器的情况下，也会报<strong>“[-] 检测到调试器”</strong>。原因应该是因为：程序没有调用<code>OutPutDebugString</code>函数也会改变错误码。</p>
<h2 id="ZwSetInformationThread（ThreadHideFromDebugger）"><a href="#ZwSetInformationThread（ThreadHideFromDebugger）" class="headerlink" title="ZwSetInformationThread（ThreadHideFromDebugger）"></a>ZwSetInformationThread（ThreadHideFromDebugger）</h2><p>一种调试器攻击。</p>
<p><code>ZwSetInformationThread</code>函数，用于设置线程的优先级。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSYSAPI NTSTATUS <span class="hljs-title">ZwSetInformationThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] HANDLE          ThreadHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] THREADINFOCLASS ThreadInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] PVOID           ThreadInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] ULONG           ThreadInformationLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>这个函数可以设置一个与线程相关的信息。查看<code>ThreadInformationClass</code>列表：<br><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311703401.png" srcset="/img/loading.gif" lazyload alt="image-20231231170307307"></p>
<p>可以看到<code>ThreadHideFromDebugger</code>，关于它的定义：<br>这个信息类只能被设置。它禁用了线程的调试事件生成。这个信息类不需要数据，因此 <code>ThreadInformation</code> 可以是一个空指针。<code>ThreadInformationLength</code> 应该是零。</p>
<p>通过为线程设置<code>ThreadHideFromDebugger</code>，可以禁止某个线程产生调试事件。</p>
<p>测试示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-comment">// #include &lt;winternl.h&gt; // 包含 NTSTATUS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 确保 NTSTATUS 已定义。如果没有，手动定义它。</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NTSTATUS</span><br><span class="hljs-keyword">typedef</span> LONG NTSTATUS;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 定义 ZwSetInformationThread 函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span> <span class="hljs-params">(WINAPI *ZW_SET_INFORMATION_THREAD)</span><span class="hljs-params">(HANDLE, DWORD, PVOID, ULONG)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ThreadHideFromDebugger 0x11 <span class="hljs-comment">// 17 in decimal</span></span><br><br><span class="hljs-comment">// 函数来禁用调试事件</span><br><span class="hljs-function">VOID <span class="hljs-title">DisableDebugEvent</span><span class="hljs-params">(VOID)</span></span><br><span class="hljs-function"></span>&#123;<br>    HMODULE hModule;<br>    ZW_SET_INFORMATION_THREAD ZwSetInformationThread;<br><br>    <span class="hljs-comment">// 获取 ntdll.dll 模块的句柄</span><br>    hModule = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;Ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (hModule == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法获取 ntdll.dll 的句柄.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取 ZwSetInformationThread 函数的地址</span><br>    ZwSetInformationThread = (ZW_SET_INFORMATION_THREAD)<span class="hljs-built_in">GetProcAddress</span>(hModule, <span class="hljs-string">&quot;ZwSetInformationThread&quot;</span>);<br>    <span class="hljs-keyword">if</span> (ZwSetInformationThread == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法获取 ZwSetInformationThread 函数的地址.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 调用函数尝试隐藏当前线程</span><br>    NTSTATUS status = <span class="hljs-built_in">ZwSetInformationThread</span>(<span class="hljs-built_in">GetCurrentThread</span>(), ThreadHideFromDebugger, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (status != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;调用 ZwSetInformationThread 失败，状态码: 0x%X\n&quot;</span>, status);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前线程已尝试隐藏自调试器.\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;测试程序开始...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 尝试禁用调试事件</span><br>    <span class="hljs-built_in">DisableDebugEvent</span>();<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.....&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我用单步测试的，在打印“当前线程已尝试隐藏自调试器.”之后延迟一会程序就会退出调试状态。</p>
<p><strong>关于怎么干掉这个反调试。（待学）</strong><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-249689.html">https://bbs.kanxue.com/thread-249689.html</a></p>
<h1 id="手动检测数据结构"><a href="#手动检测数据结构" class="headerlink" title="手动检测数据结构"></a>手动检测数据结构</h1><p>在一些情况下，程序中可能没有使用Windows API进行反调试，所以需要我们手动检查数据结构，关注一些会暴露调试器的数据结构（PEB）。</p>
<h2 id="检测BeingDebugged属性"><a href="#检测BeingDebugged属性" class="headerlink" title="检测BeingDebugged属性"></a>检测BeingDebugged属性</h2><p><code>BeingDebugged</code>如上文所说，位于PEB中的<strong>0x2偏移处</strong>；</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311603285.png" srcset="/img/loading.gif" lazyload alt="image-20231231160314219"></p>
<p>过掉这种调试的方法就是在执行跳转是，手动修改零标志（使其强制跳转或不跳转）；或者修改跳转指令；手动设置BeingDebugged属性值为0；</p>
<h2 id="检测ProcessHeap属性"><a href="#检测ProcessHeap属性" class="headerlink" title="检测ProcessHeap属性"></a>检测ProcessHeap属性</h2><p>在PEB结构的Reserved4数组中有一个未公开的位置叫做<code>ProcessHeap</code>，它被设置为加载器为进程分配的第一个堆的位置。ProcessHeap位于PEB结构的<strong>0x18偏移处</strong>。第一个堆头部有一个属性字段，它告诉内核这个堆是否在调试器中创建。这些属性叫做<code>ForceFlags</code>和<code>Flags</code>。</p>
<p>在正常情况下，系统在为进程创建第一个堆时，会将它的Flags和ForceFlags分别设为<strong>2和0</strong>，而在调试状态下，这俩个标志通常会被设为50000062h（取决于NtGlobalFlag）和40000060h。</p>
<p>同时，<code>Flags</code>位于ProcessHeap的<strong>0x0c偏移处</strong>，<code>ForceFlags</code>位于ProcessHeap的<strong>0x10偏移处</strong>。</p>
<p>因此可以写出这样一段检测代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,fs:[0x30]			;获取PEB<br>mov eax,[eax+0x18]			;获取ProcessHeap	<br>cmp dword ptr [eax+0x0C],2			;获取Flags<br>jne __debugger_detected<br>cmp dword ptr [eax+0x10],0			;获取ForceFlags<br>jne __debugger_detected<br></code></pre></td></tr></table></figure>

<p>对付这种反调试的方法之一就是手动修改ProcessHeap标志。</p>
<h2 id="检测NtGlobalFlag"><a href="#检测NtGlobalFlag" class="headerlink" title="检测NtGlobalFlag"></a>检测NtGlobalFlag</h2><p><code>NtGlobalFlag</code>位于PEB结构的<strong>0x68偏移处</strong>。因为在调试器中启动进程和正常模式下启动进程时它们创建内存堆的方式不同。如果进程是由调试器创建的，那么该标志的值会被设置成<strong>0x70</strong>。</p>
<p>检测代码：</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312311631499.png" srcset="/img/loading.gif" lazyload alt="image-20231231163106456"></p>
<p>过掉反调试的方法都差不多。</p>
<h1 id="识别调试器行为"><a href="#识别调试器行为" class="headerlink" title="识别调试器行为"></a>识别调试器行为</h1><p>在逆向工程中，进行代码分析时，可以用调试器设置断点，或者单步执行一个进程。当调试器在执行这些操作时，它们会<strong>修改</strong>进程中的代码。因此，恶意代码常使用探测<strong>INT扫描</strong>、<strong>完整性校验</strong>，以及<strong>时钟检测</strong>等几种类型的调试器行为。</p>
<h2 id="断点检测"><a href="#断点检测" class="headerlink" title="断点检测"></a>断点检测</h2><h3 id="软件断点"><a href="#软件断点" class="headerlink" title="软件断点"></a>软件断点</h3><p>原理：调试器在设置断点时的一般采用的是<strong>软件断点（INT 3）</strong>，打下INT 3后调试器会临时替换运行程序中的一条指令，当程序运行到这里时，调用<strong>调试异常处理例程</strong>。</p>
<p>INT 3 的机器码是<strong>0xCC</strong>，所以若是在关键位置检测到该指令，就可以判断进程处于调试状态。。</p>
<p>常用的反调试方法，扫描0xCC。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call $+5<br>pop edi <br>sub edi, 5<br>mov ecx, 400h<br>mov eax, 0CCh<br>repne scasb<br>jz DebuggerDetected<br></code></pre></td></tr></table></figure>

<p>这段先执行了一个函数调用，随后用pop指令将eip寄存器的值存入edi，然后将edi设置为代码的开始。接下来扫描这段代码的0xCC字节，如果发现0xCC则证明存在调试器。</p>
<p>对抗这种反调试技术的方法就是<strong>使用硬件断点</strong>。</p>
<p>示例程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取MessageBoxA函数地址</span><br>    FARPROC addr = <span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">LoadLibraryW</span>(<span class="hljs-string">L&quot;user32.dll&quot;</span>), <span class="hljs-string">&quot;MessageBoxA&quot;</span>);<br>    <br>    <span class="hljs-comment">// 读取函数入口处的第一个字节</span><br>    BYTE byteAtAddr = *(BYTE*)addr;<br>    <br>    <span class="hljs-comment">// 显示消息框作为正常功能的一部分</span><br>    <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;context&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>, MB_OK);<br><br>    <span class="hljs-comment">// 检查是否为0xCC（INT 3指令）</span><br>    <span class="hljs-keyword">if</span> (byteAtAddr == <span class="hljs-number">0xCC</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;检测到调试&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;无调试&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>用xdbg调试，<strong>Ctrl+G</strong>搜索<code>MessageBoxA</code>。在函数处下断点，之后一直单步就可以发现程序输出了检测到调试。</p>
<p>查看汇编代码：</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011026505.png" srcset="/img/loading.gif" lazyload alt="image-20240101102602420"></p>
<p>在调用完函数后，调试器扫描了esp-10处开始的字节，查找0xCC。</p>
<p>对抗：</p>
<p>在xdbg右键断点设置硬件断点，</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011029692.png" srcset="/img/loading.gif" lazyload alt="image-20240101102927639"></p>
<p>再次调试发现，变成了无调试。成功过掉。（</p>
<h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><p>先了解一下什么是<strong>硬件断点</strong>，硬件断点和<strong>DRx寄存器</strong>有关，下图是Intel CPU体系架构里对DRx寄存器的介绍。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011137550.png" srcset="/img/loading.gif" lazyload alt="image-20240101113735452"></p>
<ul>
<li>DR0~DR3就好，这四个位置一般用于设置硬件断点。</li>
<li>DR4和DR5保留，并未公开。</li>
<li>DR6是调试寄存器组状态寄存器。</li>
<li>DR7是调试寄存器组控制寄存器。</li>
</ul>
<p>硬件断点的原理是使用<strong>DR0~DR3设定地址</strong>，并使用DR7设定状态，因此最多设置<strong>4</strong>个断点。</p>
<p><strong>怎么实现硬件断点反调试？</strong></p>
<p>先获取硬件断点信息，利用函数<code>GetThreadContext</code>，它检索指定线程的上下文。</p>
<p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">GetThreadContext</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]      HANDLE    hThread,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, out] LPCONTEXT lpContext</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;	<br></code></pre></td></tr></table></figure>

<p>第一个参数是要检索其上下文线程的<strong>句柄</strong>，第二个参数指向<strong>CONTEXT结构</strong>。该结构是一个在Windows API中定义的结构体，它用于存储线程的上下文信息，包括<strong>寄存器</strong>和其他重要的状态信息。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011159462.png" srcset="/img/loading.gif" lazyload alt="image-20240101115917410"></p>
<p>因此我们需要获取CONTEXT结构体中的DRx寄存器的信息，使用<code>CONTEXT_DEBUG_REFGISTERS</code>标志。</p>
<p>示例程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CONTEXT TestContext;<br>    <span class="hljs-built_in">ZeroMemory</span>(&amp;TestContext, <span class="hljs-built_in">sizeof</span>(CONTEXT)); <span class="hljs-comment">// 将结构体清零</span><br>    TestContext.ContextFlags = CONTEXT_DEBUG_REGISTERS;<br>    <br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetThreadContext</span>(<span class="hljs-built_in">GetCurrentThread</span>(), &amp;TestContext)) &#123;<br>        <span class="hljs-keyword">if</span> (TestContext.Dr0 != <span class="hljs-number">0</span> || TestContext.Dr1 != <span class="hljs-number">0</span> || <br>            TestContext.Dr2 != <span class="hljs-number">0</span> || TestContext.Dr3 != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;硬件断点检测成功, 程序正在被调试！&quot;</span>, <span class="hljs-string">&quot;硬件断点检测&quot;</span>, MB_OK);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;没有检测到硬件断点。&quot;</span>, <span class="hljs-string">&quot;硬件断点检测&quot;</span>, MB_OK);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        DWORD dwError = <span class="hljs-built_in">GetLastError</span>();<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;GetThreadContext failed with error: &quot;</span> &lt;&lt; dwError &lt;&lt; std::endl;<br>        <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;无法获取线程上下文信息。&quot;</span>, <span class="hljs-string">&quot;错误&quot;</span>, MB_OK);<br>    &#125;<br>    <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>); <span class="hljs-comment">// 使用cin.get()或std::getchar()可能是一个更好的选择</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进行调试</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011202255.png" srcset="/img/loading.gif" lazyload alt="image-20240101120236208"></p>
<p>随便下个硬件断点，检测成功。</p>
<p><strong>采用异常来进行硬件断点反调试</strong>（待学）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Sna1lGo/p/15358626.html">https://www.cnblogs.com/Sna1lGo/p/15358626.html</a></p>
<h2 id="执行代码校验和检查"><a href="#执行代码校验和检查" class="headerlink" title="执行代码校验和检查"></a>执行代码校验和检查</h2><p>恶意代码可以计算代码段的校验并实现与扫描中断相同的目的。与扫描0xCC不同，这种检查仅执行恶意代码中机器码的<strong>CRC（循环冗余校验）</strong>或<strong>MD5校验</strong>和检查。</p>
<p>下面是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function">BOOL <span class="hljs-title">CheckIntegrity</span><span class="hljs-params">()</span> </span>&#123;<br>    PIMAGE_DOS_HEADER pDosHeader;<br>    PIMAGE_NT_HEADERS pNtHeaders;<br>    PIMAGE_SECTION_HEADER pSectionHeader;<br>    DWORD dwBaseImage = (DWORD)<span class="hljs-built_in">GetModuleHandle</span>(<span class="hljs-literal">NULL</span>);<br>    <br>    pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage;<br>    pNtHeaders = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);<br>    pSectionHeader = <span class="hljs-built_in">IMAGE_FIRST_SECTION</span>(pNtHeaders);<br>    <br>    DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage;<br>    DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData;<br>    <br>    DWORD checksum = <span class="hljs-number">0</span>;<br>    BYTE* code = <span class="hljs-built_in">reinterpret_cast</span>&lt;BYTE*&gt;(dwAddr);<br>    <br>    <span class="hljs-keyword">for</span> (DWORD i = <span class="hljs-number">0</span>; i &lt; dwCodeSize; ++i) &#123;<br>        checksum += code[i];<br>        checksum = (checksum &gt;&gt; <span class="hljs-number">31</span>) | (checksum &lt;&lt; <span class="hljs-number">1</span>); <span class="hljs-comment">// ROL checksum, 1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (checksum != <span class="hljs-number">0x46ea24</span>) &#123;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CheckIntegrity</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Integrity check passed.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Integrity check failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在这个程序中，<code>checksum</code>变量计算为代码段中所有字节的累加和，并对每个字节累加后进行一次ROL。然后将这个 <code>checksum</code> 和一个预设的校验和值比较。</p>
<p>关于绕过，可以修改检查函数或者校验和值。</p>
<h2 id="时钟检测"><a href="#时钟检测" class="headerlink" title="时钟检测"></a>时钟检测</h2><p>程序调试时，进程的运行速度大大降低（单步调试）。</p>
<p>有如下俩种用时钟检测来探测调试器存在的方法：</p>
<ul>
<li>记录执行一段操作前后的时间戳，然后比较这俩个时间戳，如果存在滞后，则可以认为存在调试器。</li>
<li>记录一个异常前后的时间戳。如果不调试进程，可以很快处理完异常，因为调试器处理异常的速度非常慢。因此默认情况下，调试器处理异常需要人为干预，这导致大量延迟。</li>
</ul>
<h3 id="rdstc指令"><a href="#rdstc指令" class="headerlink" title="rdstc指令"></a>rdstc指令</h3><p>rdtsc指令（操作码0x0F31）用于获取CPU自开机运行起的时钟周期数，并且将其作为一个64位的值存入edx和eax寄存器中。执行俩次rdstc指令，然后比较这俩次取值之间的差值</p>
<p>汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">rdtsc<br>mov ecx, eax<br>mov ebx, edx<br>;计算俩个rdtsc的偏移量<br>rdtsc<br>cmp edx, ebx<br>ja __debugger_found<br>sub eax, ecx<br>cmp eax, 0x200<br>ja __debugger_found<br></code></pre></td></tr></table></figure>

<p>俩次调用rdtsc,先检查了高位edx相不相同，相同的话再检查低位的差值是否大于0x20。</p>
<h3 id="QueryPerformanceCounter或GetTickCount"><a href="#QueryPerformanceCounter或GetTickCount" class="headerlink" title="QueryPerformanceCounter或GetTickCount"></a>QueryPerformanceCounter或GetTickCount</h3><p><code>QueryPerformanceCounter</code>函数检索性能计数器的当前值，这是一个高分辨率 (&lt;1us) 时间戳，可用于时间间隔度量。</p>
<p><code>GetTickCount</code>检索自系统启动以来经过的毫秒数。</p>
<p>这俩个函数都可以用于时钟检测。</p>
<p>下面是一个GetTickCount的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function">BOOL <span class="hljs-title">IsDebuggerPresentWithTiming</span><span class="hljs-params">()</span></span>&#123;<br>    DWORD startTick,endTick,elapsed;<br>    <br>    <span class="hljs-comment">// 获取初始的 tick 计数</span><br>    startTick = <span class="hljs-built_in">GetTickCount</span>();<br><br>    <span class="hljs-comment">// 此处可以添加代码</span><br>    <span class="hljs-built_in">OutputDebugString</span>(<span class="hljs-string">&quot;Debugger check...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 获取结束的 tick 计数</span><br>    endTick = <span class="hljs-built_in">GetTickCount</span>();<br><br>    <span class="hljs-comment">// 计算经过的 tick 数</span><br>    elapsed = endTick - startTick;<br><br>    <span class="hljs-comment">// 如果时间差超出预设值，则可能存在调试器。</span><br>    <span class="hljs-keyword">if</span> (elapsed &gt; <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">return</span> TRUE;<br>    &#125;<br>    <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsDebuggerPresentWithTiming</span>())&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;可能检测到调试器！&quot;</span> &lt;&lt;std::endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;没有检测到调试器！&quot;</span> &lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>过掉时钟检测比较好的办法是在检测指令之后下断点。例如：</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011113952.png" srcset="/img/loading.gif" lazyload alt="image-20240101111332854"></p>
<h2 id="父进程检测"><a href="#父进程检测" class="headerlink" title="父进程检测"></a>父进程检测</h2><p>从理论上讲，一个程序被正常启动时，其父进程应该是<strong>Exploer.exe(资源管理器启动)<strong>、</strong>cmd.exe（命令行启动）</strong>或者<strong>Services.exe（系统服务）</strong>中的一个。如果某一个进程的父进程并非上述3个进程之一，一遍可以认为它被调试了（或者被内存补丁之类的Loader程序加载了）。</p>
<p>实现这种检测的方法：</p>
<ol>
<li>通过TEB（TEB.ClientId）或者GetCurrentProcessId来检索当前进程的PID。</li>
<li>通过Process32First、Process32Next得到所有进程的列表，判断explorer.exe的PID（通过PROCESSENTERY.szExeFile）和通过PROCESSENTRy.th32ParentProcessID获得的当前进程的父进程ID是否相同。</li>
<li>如果父进程的PID不是上述三种的其中之一，那么目标进程很可能被调试了。</li>
</ol>
<h1 id="干扰调试器的功能"><a href="#干扰调试器的功能" class="headerlink" title="干扰调试器的功能"></a>干扰调试器的功能</h1><h2 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h2><p><strong>Thread Local Storage(TLS)，即线程本地存储</strong>，是Windows为解决一个进程中多个线程同时访问全局变量而提供的机制。</p>
<p>TLS回调函数就是在程序加载到调试器后，TLS回调会<strong>先于</strong>程序入口执行之前运行代码，这样就可以提前进行反调试操作或者修改代码。</p>
<p>在IDA中可以使用 <code>Ctrl + E</code> 查看二进制的入口点。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011210653.png" srcset="/img/loading.gif" lazyload alt="image-20240101121030613"></p>
<p>在PEview等PE工具中也可以查看.tls段，因为通常情况下，正常程序不使用.tls段。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401011211398.png" srcset="/img/loading.gif" lazyload alt="image-20240101121149354"></p>
<h2 id="使用异常×"><a href="#使用异常×" class="headerlink" title="使用异常×"></a>使用异常×</h2><p>（待学）。。。</p>
<h2 id="插入中断"><a href="#插入中断" class="headerlink" title="插入中断"></a>插入中断</h2><h3 id="插入INT-3"><a href="#插入INT-3" class="headerlink" title="插入INT 3"></a>插入INT 3</h3><p>调试器使用 INT 3设置软件断点，所以一种反调试技术就是在合法代码中插入0xCC来欺骗调试器，使其认为这些0xCC机器码是自己设置的段带你。</p>
<p>一些调试器用跟踪自身设置的断点的方法来避免这种反调试技术。</p>
<h3 id="插入INT-2D断点×"><a href="#插入INT-2D断点×" class="headerlink" title="插入INT 2D断点×"></a>插入INT 2D断点×</h3><h3 id="插入ICE断点×"><a href="#插入ICE断点×" class="headerlink" title="插入ICE断点×"></a>插入ICE断点×</h3><p>嗯。待学（INT 2D。ICE是什么。）</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Windows反调试技术</div>
      <div>http://sciurdae.online/2024/04/02/Windows反调试技术/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Sciurdae</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/04/02/Windows%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/" title="Windosw内核理论基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Windosw内核理论基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/04/02/hello-world/" title="Hello World">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
  const locale = {
	  nick: '昵称',
	  nickError: '昵称hai没填!',
	  placeholder: '欢迎交流学习欸~请先输入你的昵称！\n填写QQ邮箱可以获取你的QQ头像同时可以收到邮箱回信提醒o~\n匿名请直接发起评论~',
	  sofa: '评论区空空如( •̀ ω •́ )y~',
	  refresh: '刷新亿下~',
	  login: '登录(可选)',
	  submit: '发布',
    anonymous: '不愿透露姓名的某人',
  }
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://cdn.staticfile.org/waline/2.15.5/waline.min.css')
      Fluid.utils.createScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://blog-comment-git-main-sciurdaes-projects.vercel.app/","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":true,"avatarCDN":"","avatarForce":false,"requiredFields":[],"emoji":["https://unpkg.com/@waline/emojis@1.2.0/bilibili","https://unpkg.com/@waline/emojis@1.2.0/qq","https://unpkg.com/@waline/emojis@1.2.0/tieba"]},
          {
            el: '#waline',
            path: window.location.pathname,
			locale,
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div style="font-size: 1rem"> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </div> <div style="font-size: 1rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        <span style='font-size: 1.1rem'>总访问量 
        <span id="leancloud-site-pv"></span>
         次</span>
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        <span style='font-size: 1.1rem'>总访客数 
        <span id="leancloud-site-uv"></span>
         人</span>
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/decorate.js"></script>
<script src="/js/customm.js"></script>
<script src="/js/scrollAnimation.js"></script>
<script src="/js/codeType.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?0c762af872e1027897225f1a1295b11e"></script><script>L2Dwidget.init({"dialog":{"enable":true,"text":["汪","汪汪","汪呜"]},"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/model/katou_01/katou_01.model.json"},"display":{"superSample":2,"width":200,"height":400,"position":"right","hOffset":20,"vOffset":0},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body>
</html>
