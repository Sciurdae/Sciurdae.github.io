

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/sunsun.png">
  <link rel="icon" href="/img/sunsun.png">
  <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="referrer" content="no-referrer"/>
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#f4cccc">
  <meta name="author" content="Sciurdae">
  <meta name="keywords" content="">
  
    <meta name="description" content="Windows内核理论基础学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Windosw内核理论基础">
<meta property="og:url" content="http://sciurdae.online/2024/04/02/Windows%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Sciurdae&#39;s 小窝">
<meta property="og:description" content="Windows内核理论基础学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401021844608.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312261638491.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312261556935.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401021754745.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401030050046.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031442520.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031515131.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031733063.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031958530.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040002657.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040028701.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040040028.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040046513.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040047536.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401041606154.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401041650999.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312262012839.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312262020779.png">
<meta property="og:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401041702378.png">
<meta property="article:published_time" content="2024-04-02T12:24:57.713Z">
<meta property="article:modified_time" content="2024-04-03T01:38:01.431Z">
<meta property="article:author" content="Sciurdae">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401021844608.png">
  
  
  
  <title>Windosw内核理论基础 - Sciurdae&#39;s 小窝</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/decorate.css">
<link rel="stylesheet" href="/css/customm.css">
<link rel="stylesheet" href="/css/cloudedGlass.css">
<link rel="stylesheet" href="/css/scrollAnimation.css">
<link rel="stylesheet" href="/css/selection.css">
<link rel="stylesheet" href="/css/macBorder.css">
<link rel="stylesheet" href="/css/scrollbar.css">
<link rel="stylesheet" href="/css/font-custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"sciurdae.online","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"SRfFH0K09R040yFG7bfIbwPN-MdYXbMMI","app_key":"ipbxy4I7kbGQTwmWce2SnvyU","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.1.1"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Sciurdae&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/guestbook/" target="_self">
                <i class="iconfont icon-comment-fill"></i>
                <span>guestbook</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/sun.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Windosw内核理论基础</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-02 20:24" pubdate>
          2024年4月2日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          118 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          阅读次数 <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Windosw内核理论基础</h1>
            
            
              <div class="markdown-body">
                
                <p>Windows内核理论基础学习</p>
<span id="more"></span>
<h1 id="Windosw内核理论基础"><a href="#Windosw内核理论基础" class="headerlink" title="Windosw内核理论基础"></a>Windosw内核理论基础</h1><h2 id="Windows体系结构"><a href="#Windows体系结构" class="headerlink" title="Windows体系结构"></a>Windows体系结构</h2><h3 id="CPU权限级别"><a href="#CPU权限级别" class="headerlink" title="CPU权限级别"></a>CPU权限级别</h3><p><strong>系统内核层</strong>，又称<strong>零环</strong>（Ring0，简称R0；与此对应的是<strong>3环</strong>，R3，应用层）；实际上是CPU的4个级别，CPU在设计时将CPU的运行级别从内到外分为4个层级R0-R3，R0权限最高依次降低（实际上，现在只区分R0和R3，并没有使用R1和R2）。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401021844608.png" srcset="/img/loading.gif" lazyload alt="image-20240102184406550"></p>
<p>分级的<strong>目的</strong>是为了<strong>保护系统的稳定性和安全性</strong>。通过限制某些操作只能在高权限级别下执行，操作系统可以防止用户级应用程序意外或恶意地修改关键系统资源，进而导致系统崩溃或安全漏洞。</p>
<p>Windows 体系结构简图：<br><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312261638491.png" srcset="/img/loading.gif" lazyload alt="image-20231226163845412"></p>
<p>从上图可以看到，Windows使用双模式来保护操作系统本身，用户模式对应的就是R3，内核模式即R0。在这种架构下，应用程序的代码<strong>只能</strong>运行在用户模式下，每当它需要使用到系统内核或内核的扩展模块（内核驱动程序）所提供的服务时，应用程序通过<strong>硬件指令</strong>从用户模式切换到内核模式中；当系统内核完成了所请求的服务以后，控制权又回到用户模式代码。</p>
<h3 id="内存空间布局"><a href="#内存空间布局" class="headerlink" title="内存空间布局"></a>内存空间布局</h3><p>Windows中，用户代码和内核代码有各自的运行环境，并且它们可以访问的内存空间也不同。</p>
<p>以x64为例，在4G的虚拟内存空间中，WIndows系统的内存分为<strong>内核空间</strong>和<strong>应用空间</strong>，每部分各占2GB。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312261556935.png" srcset="/img/loading.gif" lazyload alt="image-20231213212456137"></p>
<p>其中用户空间占用低地址（00000000 ~ 7FFFEFFF），内核空间占用高地址(7FFF000 ~ FFFFFFFF)；若是开启了大地址空间模式的程序（LARGE_ADDRESS_AWARE），则内存空间布局会变成3GB 的用户空间，和 1GB 的内核空间。</p>
<h3 id="Windows内核结构"><a href="#Windows内核结构" class="headerlink" title="Windows内核结构"></a>Windows内核结构</h3><p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401021754745.png" srcset="/img/loading.gif" lazyload alt="image-20240102175441676"></p>
<p>如图，Windows内核中主要可以分成三层：<strong>硬件抽象层</strong>（HAL），<strong>内核层</strong>（也称微内核micro-kernel），<strong>执行体层</strong>。</p>
<p>内核层实现操作系统的基本机制，而所有的策略决定则留给执行体。执行体中的对象绝大多数封装了一个或者多个内核对象，并且通过某种方式（比如对象句柄）暴露给应用程序。</p>
<p>Windows内核为用户模式提供了一组<strong>系统服务</strong>，供应用程序使用内核中的功能。应用程序通常并不直接调用这些系统服务，而是通过一组系统DLL，最终通过<strong>ntdll.dll</strong>切换到内核模式下的执行体API函数中，以调用内核中的系统服务。</p>
<p><strong>Ntdll.dll是链接用户模式代码和内核模式系统服务的桥梁。</strong>对于内核提供的每一个系统服务，该DLL都提供一个相应的<strong>存根函数</strong>，这些存根函数的名称以“<strong>Nt</strong>”作为前缀，例如<code>NtCreateProcess</code>、<code>NtOpenFile</code>等。另外ntdll.dll还提供了许多系统级的支持函数，比如映像加载器函数（以“<strong>Ldr</strong>”为前缀）、系统时间函数（以“<strong>Etw</strong>”为前缀），以及一般的运行支持函数（以“<strong>Rtl</strong>”为前缀）和字符串支持函数等。</p>
<p>执行体API函数接收的参数来自于各种应用程序，因此为了保证系统的安全以及抵抗来自用户模式的恶意攻击，所有的执行体API都必须保证参数的<strong>有效性</strong>。通常执行体系统服务函数会在其开始处，对所接收的参数逐一探查它们的可访问性。例如如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PreviousMode = <span class="hljs-built_in">KeGetPreviousMode</span>();<br><span class="hljs-keyword">if</span> (PreviousMode != kernelMode)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-built_in">ProbeForWrite</span>(InputInformation,InputInformationLength,<span class="hljs-built_in">sizeof</span>(ULONG));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ARGUMENT_PRESENT</span>(ReturnLength))&#123;<br>            <span class="hljs-built_in">ProbeForWriteUlong</span>(ReturnLength);<br>        &#125; <span class="hljs-built_in">except</span>(EXCEPTION_EXECUTE_HANDLER)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetExceptionCode</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li>调用 <code>KeGetPreviousMode</code> 函数来获取当前的执行模式（内核模式or用户模式）</li>
<li>用 <code>if</code>判断是否是内核模式（kernelMode）</li>
<li>使用了一个<code>try&#123;...&#125;except()&#123;...&#125;</code> 异常处理，try中包含一些堆内存的探测（Probe）操作</li>
<li><code>ProbeForWirte</code>是一个检查内存可写性的函数，用于检查<code>InputInformation</code>指向的内存区域是否可以安全写入数据，第二三个参数分别是数据的长度和数据的大小。</li>
<li>接着检查是否传递了 <code>ReturnLength</code>参数，如果传递了就进一步检查内存可写性</li>
<li>except 如果触发了异常，用<code>GetExceptionCode</code>获取错误码</li>
</ul>
<p><strong>Windows内核中的关键组件</strong>：</p>
<h4 id="硬件抽象层（HAL）"><a href="#硬件抽象层（HAL）" class="headerlink" title="硬件抽象层（HAL）"></a>硬件抽象层（HAL）</h4><p><strong>硬件抽象层（Hardware Abstraction Layer，HAL）</strong>，这一层把所有与硬件相关联的代码逻辑隔离到一个专门的模块中，为操作系统的上层提供一个<strong>抽象</strong>的、一致的硬件资源模型。这使得上层的模块无须考虑硬件的差异，它们通过HAL而不是直接访问硬件。</p>
<p>在Windows中，<strong>HAL是一个独立的动态链接库</strong>。HAL提供了一些例程供其他内核模块或设备驱动程序调用，这使得一个驱动程序可以支持同样的设备在各种硬件平台上运行。HAL不仅涵盖了处理器的体系结构，也涉及了中断控制器、单处理器或多处理器等硬件条件。</p>
<h4 id="内核层"><a href="#内核层" class="headerlink" title="内核层"></a>内核层</h4><p>这是大内核中的小内核，也称<strong>微内核</strong>。它是<strong>内核模块ntoskrnl.exe</strong>的<strong>下层</strong>部分(上层为执行体),最接近HAL层,负责<strong>线程调度</strong>和<strong>中断、异常的处理</strong>。对于多处理器系统，它还负责同步处理器之间的行为，以优化系统的性能。</p>
<p>Windows的内核实现了<strong>抢占式线程调度机制</strong>，按照优先级顺序将线程分配到处理器上，并且允许高优先级的线程中断或抢占低优先级的线程。每个线程有一个<strong>基本优先级值</strong>（base priority）和一个<strong>动态优先级值</strong>。根据这俩个值，内核根据调度规则来切换线程，让系统更快响应用户的动作，以及在系统服务和其他低优先级进程之间平衡处理器资源的分配。</p>
<p>Windows内核按照面向对象的思想来设计，它管理俩种类型的对象：<strong>分发器对象</strong>和<strong>控制对象</strong>。分发器对象实现了各种同步功能，这些对象的状态会影响线程的调度。Windows内核实现的分发器对象包括事件（event）、突变体（mutant）、信号量（semaphore）、进程（process）、线程（thread）、队列（queue）、门（gate）和定时器（timer）。控制对象被用于控制内核的操作但是不影响线程的调度，它包括异步过程调用（APC）、延迟过程调用（DPC），以及中断对象等。</p>
<h4 id="执行体层"><a href="#执行体层" class="headerlink" title="执行体层"></a>执行体层</h4><p>执行体是<strong>内核模块ntoskrnl.exe的上层部分</strong>，它包含5种类型的函数：</p>
<ul>
<li><strong>系统服务调度函数（System Service Dispatch Functions）</strong>：这些函数主要负责响应系统服务请求。当用户模式应用程序请求操作系统服务时，这些函数会被调用。例如<code>NtCreateFile</code>、<code>NtReadFile</code>等函数。</li>
<li><strong>内核模式支持函数（Kernel Mode Support Functions）</strong>：这类函数提供给其他内核模式组件使用，以执行各种底层任务，如内存管理、进程和线程管理等。例如<code>ExAlloctePool</code>：分配内核池内存、<code>KeSetEvent</code>：设置一个事件对象的状。</li>
<li><strong>执行对象管理函数（Executive Object Management Functions）</strong>：这些函数用于管理Windows中的各种执行对象，如进程、线程、事件、信号量等。例如 <code>ObOpenObjectByPointer</code> :根据对象指针打开对象、 <code>ExCreateCallback</code>：创建一个回调对象。</li>
<li><strong>安全引用监视器函数（Security Reference Monitor Functions）</strong>：这些函数用于实现操作系统的安全机制，包括访问控制、权限检查等。例如 <code>SeAccessCheck</code>：检查访问权限。</li>
<li><strong>I&#x2F;O系统支持函数（I&#x2F;O System Support Functions）</strong>：这些函数支持输入&#x2F;输出系统的操作，包括文件系统的管理、设备驱动程序的交互等。例如 <code>IoWriteErrorLogEntry</code>：写入错误日志条目。</li>
</ul>
<p>关于函数前缀，这些函数都以固定的前缀开始，分别属于内核中不同的管理模块：</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401030050046.png" srcset="/img/loading.gif" lazyload alt="image-20240103005056886"></p>
<p>与应用层函数不同，在windows操作系统中调用内核函数必须要关注<strong>中断请求级别（IRQL，Interrupt Request Level）</strong>。</p>
<p>IRQL 是一个表示<strong>中断优先级</strong>的数字，用于确保处理器在处理不同的任务时维持正确的操作顺序和安全性。操作系统内核使用不同的 IRQL 来管理对硬件资源的访问，以及处理不同级别的中断和异常。</p>
<p>在调用内核函数时，必须要确保当前的IRQL与被调用函数所要求的级别<strong>相符</strong>。不遵守这一规则可能导致系统崩溃或数据损坏。IRQL的级别如下：</p>
<ol>
<li><strong>被动级别（PASSIVE_LEVEL）</strong>：这是最低的IRQL级别。在此级别，线程可以被抢占，可以执行任何类型的内核模式代码，包括页面操作。</li>
<li><strong>APC级别（APC_LEVEL）</strong>：此级别用于阻止异步过程调用（APC）的执行。</li>
<li><strong>调度级别（DISPATCH_LEVEL）</strong>：在此级别，可以阻止<strong>线程调度</strong>，但仍允许处理硬件中断。很多非分页内存操作需要在此级别或更低级别执行。</li>
<li><strong>DIRQL（设备IRQL）</strong>：这是特定于设备的中断级别。不同的设备驱动程序可能会使用不同的DIRQL。</li>
<li><strong>高IRQL（HIGH_LEVEL）</strong>：这是最高的IRQL级别，用于系统关键操作，此时几乎所有的中断都被禁止。</li>
</ol>
<p>开发内核模式驱动程序时，合理地管理IRQL至关重要。如果一个函数要求在低IRQL下运行，而当前IRQL较高，就不能直接调用那个函数；反之亦然。不正确的IRQL处理可能导致系统不稳定或蓝屏（BSOD）。</p>
<p>执行体中除了函数组成，还包含了如图中的<strong>多个重要的组件</strong>，以下：</p>
<ul>
<li><strong>内存管理器</strong>：实现了虚拟内存管理，既负责系统地址空间的内存管理，又为每个进程提供了一个私有的地址空间，支持进程之间的内存共享。内存管理器也为缓存管理器提供了底层支持。</li>
<li><strong>缓存管理器</strong>：它为文件系统提供了统一的数据缓存支持，允许文件系统驱动程序将磁盘上的数据映射到内存中，并通过内存管理器来协调物理内存的分配。</li>
<li><strong>文件系统</strong>：管理文件和目录的创建、读写和组织。</li>
<li><strong>进程和线程管理器</strong>：负责进程线程的创建和终止。在Windows中，对于进程和线程的底层支持是在内核层提供的，执行体只是在其基础上提供了一些语义和功能。</li>
<li><strong>即插即用管理器</strong>：负责列举设备，加载并初始化设备所需的驱动程序。还负责检测系统中的设备变化。</li>
<li><strong>安全引用监视器（SRM）</strong>：该组件强制在本地计算机上实施安全策略，它守护着操作系统的资源，执行对象的保护和审计。</li>
<li><strong>配置管理器</strong>：管理系统注册表，提供系统配置和启动信息。</li>
<li><strong>I&#x2F;O管理器</strong>：实现了与设备无关的输入和输出功能，负责将I&#x2F;O请求分发给正确的设备驱动程序以便进一步处理。</li>
<li><strong>对象管理器</strong>：它负责创建、管理、删除Windows执行体对象，以及用于表达操作系统资源的抽象数据类型，比如进程、线程和各种同步对象。</li>
<li><strong>局域网管理器（本地过程调用，LPC）</strong>：负责处理进程之间的通信，管理消息传递和远程过程调用。</li>
</ul>
<h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><p>在内核中除了内核模块ntoskrnl.exe和HAL以外，其他模块几乎都以<strong>设备驱动程序</strong>的形式存在。</p>
<p>Windows中的设备驱动程序，并不一定对应物理设备；它既可以创建虚拟设备，也可以与设备无关，它仅仅是内核的<strong>扩展模块</strong>。从<strong>软件结构</strong>角度而言，可以认为设备驱动程序是Windows内核的一种扩展机制，系统通过设备驱动程序来支持新的物理设备或者扩展功能。</p>
<p>设备驱动程序是可以加载到系统中的模块，其文件扩展名为**.sys<strong>，其格式是标准的 <strong>PE文件格式</strong>。驱动程序中的代码运行在内核下，尽管它们可以直接操纵硬件，但理想的情况是，</strong>调用HAL**中的函数与硬件打交道，因此，驱动程序往往用C&#x2F;C++语言来编写，从而可以方便地在Windows所支持的体系结构之间进行源代码层次上的移植。</p>
<p>根据设备驱动程序的<strong>功能和行为</strong>可以将设备驱动程序分为三类：</p>
<ul>
<li><strong>即插即用驱动程序</strong>：支持即插即用技术的驱动程序。它们可以在设备连接到计算机时自动被识别和配置，无需用户手动干预。</li>
<li><strong>非即插即用驱动程序</strong>：不支持即插即用技术的驱动程序。可能在安装时需要用户手动配置。</li>
<li><strong>文件系统驱动程序</strong>：专门用于处理文件操作的驱动程序，如管理文件的存取、文件系统的结构等。</li>
</ul>
<p>即插即用驱动程序，也可以称为<strong>WDM（Windows Driver Model）驱动程序</strong>。WDM是一种设备驱动模型，它提供了一个<strong>统一的框架</strong>，使驱动程序可以在不同版本的WIndwos操作系统上运行。</p>
<p>WDM通常分为三个层次：</p>
<ul>
<li><strong>总线驱动程序</strong>：负责管理总线上的设备，也为总线上的设备提供了访问总线资源的方法。</li>
<li><strong>功能驱动程序</strong>：负责管理具体的设备，向操作系统提供该设备的功能。</li>
<li><strong>筛选&#x2F;过滤驱动程序</strong>：监视一个设备的I&#x2F;O请求以及其处理过程，增加或改变一个设备或驱动程序的行为。</li>
</ul>
<p>在WDM中，每个硬件设备都有一个设备驱动程序栈（简称<strong>设备栈</strong>），其中包含一个总线驱动程序和一个功能驱动程序，以及零个或多个过滤驱动程序。</p>
<h4 id="文件系统-存储管理"><a href="#文件系统-存储管理" class="headerlink" title="文件系统&#x2F;存储管理"></a>文件系统&#x2F;存储管理</h4><p><strong>在现代操作系统中</strong>，文件系统是外部存储设备的标准接口，它为应用程序使用这些设备中的数据提供了统一的抽象，多个应用程序和系统本身可以共享使用这些设备。</p>
<p><strong>在Windows中</strong>，文件系统的接口部分由I&#x2F;O管理器定义和实现，但文件系统的实现部分位于专门的一类驱动程序中。但文件系统接收到I&#x2F;O请求时，它会根据文件系统格式规范，将这些请求转变为更底层的对于外部存储设备的I&#x2F;O请求，通过它们的设备驱动程序来完成原始的I&#x2F;O请求。</p>
<p>因此，文件系统的驱动程序定义了外部存储设备中数据的<strong>逻辑结构</strong>，使得这些数据可直接被操作系统和应用程序使用。</p>
<p>这些文件系统驱动程序负责管理磁盘上的文件和目录，处理文件的创建、读取、写入和删除操作，提供了文件存储和访问的基本功能。</p>
<p>常见的文件系统：</p>
<ul>
<li><strong>NTFS（NT File System）</strong>：这是Windows的原生文件系统，其驱动程序为ntfs.sys。NTFS是专门为Windows设计的，它提供了许多高级的如元数据支持、数据压缩加密的功能，同时支持大型存储卷和大文件。</li>
<li><strong>FAT（File Allocation Table）</strong>：这是从DOS时代发展起来的文件系统格式，格式规范相对简单，目前主要用于兼容老版本的操作系统，以及用于移动设备以便跨操作系统传送数据。</li>
</ul>
<p>文件系统的底层是对<strong>存储设备</strong>的管理。大容量存储设备以“<strong>分区（Partition）</strong>”和“<strong>卷（volume）</strong>”来管理整个存储空间。</p>
<p><strong>分区</strong>是指存储设备上<strong>连续的存储区域</strong>（连续的扇区），而<strong>卷</strong>是指<strong>扇区的逻辑集合</strong>。一个卷内部的扇区可能来自一个分区，也可能来自多个分区，甚至来自不同的磁盘。<strong>文件系统则是卷内部的逻辑结构。</strong></p>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>在Windows操作系统中，网络是由一系列<strong>网络驱动程序</strong>和<strong>网络协议栈</strong>组成。</p>
<p>Windows内核层中的网络相关组件：</p>
<ul>
<li><strong>网络驱动程序（Network Drivers）</strong>：负责管理物理网络接口卡（NIC）或虚拟网络适配器的通信。</li>
<li><strong>协议栈（Protocol Stack）</strong>：是一个多层次的协议栈，用于处理网络通信。这个协议栈包括了各种网络协议，如TCP&#x2F;IP、UDP、ICMP等。协议栈负责数据包的封装、路由、传输和解包，确保数据在网络中的正确传输。</li>
<li><strong>套接字（Sockets）</strong>：套接字是应用程序与网络协议栈之间的接口，允许应用程序创建网络连接、发送和接收数据。Windows内核还提供了套接字API，应用程序可以使用这些API与网络进行交互。</li>
<li><strong>网络服务（Network Services）</strong>：Windwos操作系统还提供了各种网络服务，如DHCP客户端、DNS客户端、网络发现服务等，它们能够进行获取IP地址，解析域名或发现网络设备等操作。</li>
<li><strong>网络筛选器驱动程序（Network Filter Drivers）</strong>：该驱动程序允许实施网络策略和安全性控制，如防火墙和安全软件可能会使用网络筛选器驱动程序来监视和过滤网络流量。</li>
</ul>
<p>Windows为应用程序提供了多种网络API：</p>
<ul>
<li><strong>Winsock（Windows Sockets）</strong> ： 套接字API，允许应用程序使用套接字进行网络通信。可以使用Winsock来创建TCP&#x2F;IP和UDP网络连接，发送和接收数据。</li>
<li><strong>HTTP API</strong>：允许应用程序创建HTTP服务器和客户端，发送HTTP请求、接收HTTP响应，并处理Web服务。</li>
<li><strong>WebSocket API</strong>：这是一种双向通信的说协议，允许实时数据传输，适用于在线游戏、即时聊天等应用。</li>
<li><strong>WebRTC API</strong>：一种用于实时音视频通信的开放标准，可以用于创建支持视频会议、实时音频通话等应用程序。</li>
<li><strong>UPnP API</strong>：一种用于自动发现和配置网络设备的协议。</li>
<li><strong>WinINet API</strong>：WinINet提供了对Internet资源的访问，包括HTTP、FTP和Gopher等协议，它允许应用程序进行Web页面下载、文件上传和下载等操作。</li>
<li><strong>Network Management API</strong>：网络管理API，允许应用程序管理网络设置、配置网络连接和查看网络状态。</li>
</ul>
<p>这些网络API都提供了用户模式的<strong>动态链接库（DLL）</strong>。当应用程序通过这些DLL发出网络I&#x2F;O请求时，它们将这些请求传递给内核中相应的驱动程序。通常，这些网络API要么通过专门的<strong>系统服务</strong>切换到内核模式，比如命名管道和邮件槽就有专门的系统服务；要么通过标准的<strong>系统服务接口</strong>，比如<code>NtReadFile</code>、<code>NtWriteFile</code>和<code>NtDeviceIoControlFile</code>，由<strong>I&#x2F;O管理器</strong>和<strong>对象管理器</strong>将网络请求转送至对应的驱动程序中。</p>
<h3 id="Windows子系统"><a href="#Windows子系统" class="headerlink" title="Windows子系统"></a>Windows子系统</h3><p>Windows子系统是Windows操作系统的组成部分，用于支持<strong>不同类型</strong>的应用程序和环境在Windows平台上运行。每个子系统专门设计用于处理特定类型的应用程序和操作环境。</p>
<p>Windows提供了多种子系统，同时在PE文件格式中的<strong>SubSystem域</strong>指示了可执行文件的子系统类型，即程序应在何种环境下运行；SubSystem域通常包含<strong>一个数字值</strong>，代表不同的子系统类型。</p>
<p>以下是一些<strong>常见的SubSystem及其对应的子系统</strong>：</p>
<ol>
<li><p>**Native (0)**：</p>
<p>Native子系统表示该PE文件是一个本地的执行文件，通常是驱动程序或操作系统内核组件。这些文件在操作系统内核模式下运行。</p>
</li>
<li><p>**Windows GUI (2)**：</p>
<p>Windows GUI子系统表示该PE文件是一个图形用户界面（GUI）应用程序。它运行在Windows桌面环境中，通常有用户界面和窗口。</p>
</li>
<li><p>**Windows CUI (3)**：</p>
<p>Windows CUI子系统表示该PE文件是一个字符用户界面（CUI）应用程序。它通常是命令行应用程序，没有图形界面，用户通过控制台来与之交互。</p>
</li>
<li><p>**OS&#x2F;2 CUI (5)**：</p>
<p>OS&#x2F;2 CUI子系统表示该PE文件是一个OS&#x2F;2字符用户界面应用程序。这种类型的应用程序通常用于运行在IBM OS&#x2F;2环境中。</p>
</li>
<li><p>**Posix CUI (7)**：</p>
<p>Posix CUI子系统表示该PE文件是一个POSIX兼容的字符用户界面应用程序。它适用于在Windows上运行UNIX&#x2F;Linux应用程序。</p>
</li>
</ol>
<p>Windows子系统中既有用户模式部分，也有内核模式部分。内核模式部分的核心是<strong>win32k.sys</strong>，虽然它的形式是一个驱动程序，但实际上它并不处理I&#x2F;O请求，相反，它向代码<strong>提供大量的系统服务</strong>。从功能上讲，它包含俩部分：<strong>窗口管理</strong>和<strong>图形设备接口</strong>。其中窗口管理部分负责<strong>收集和分发消息</strong>，以及<strong>控制窗口显示</strong>和<strong>管理屏幕输出</strong>；图形设备接口部分包含各种<strong>形状绘制</strong>以及<strong>文本输出功能</strong>。</p>
<h4 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h4><p>Windows子系统的用户界面管理有一个<strong>层次结构</strong>，通常应用程序只是在一个默认的桌面上运行。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031442520.png" srcset="/img/loading.gif" lazyload alt="image-20240103144202326"></p>
<p>每个子系统会话都有自己的会话空间，属于某一个会话的资源将会从该会话空间中分配。当用户登录到Windwos中时，操作系统为该用户建立一个会话；即使用户通过远程桌面或者终端服务连接到一个系统中。系统也会为该用户建立一个单独的会话。</p>
<p>在一个会话中，有一个<strong>交互式窗口站</strong>，可能还有<strong>非交互式窗口站</strong>。在交互式窗口站中通常有三个桌面：登录桌面、默认桌面和屏幕保护桌面。交互式窗口站有独立的剪贴板、键盘、鼠标、显示器等，在它的三个桌面中，任一时刻只有一个是激活的，输入输出设备归激活的桌面所有。</p>
<p>在每个桌面，都有一个<strong>顶级窗口列表</strong>，这些窗口往往可以相互重叠，有系统菜单、最大化&#x2F;最小化按钮和滚动条等。通常各个图形界面应用程序的主窗口属于当前桌面的顶级窗口。在Windows中，窗口可以有子窗口，子窗口占据父窗口的客户区域。因此，桌面上的窗口形成了一个层次结构。<strong>一个窗口下总是可以创建它自己的子窗口。</strong></p>
<p>Windows为常用的窗口定义了一些<strong>窗口类（window class）</strong>。窗口类规定了其对象将如何响应各种信息，包括系统发送给它的消息和用户触发的消息。</p>
<p>Windows子系统会话有一个<strong>RIT（Raw Input Thread）线程</strong>，负责从输入设备读取原始的输入时间，生成消息寄送到正确的线程消息队列。</p>
<h4 id="图形设备接口"><a href="#图形设备接口" class="headerlink" title="图形设备接口"></a>图形设备接口</h4><p>Windows的图形引擎有俩方面特点：</p>
<ul>
<li>提供了一套与设备无关的编程接口，即GDI，这使得应用程序可以适应各种底层显示设备的差异</li>
<li>应用程序与图形设备驱动之间通信足够高效。在频繁输出和刷新图形元素的情况下，windows也能提供良好的视觉效果。</li>
</ul>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031515131.png" srcset="/img/loading.gif" lazyload alt="image-20240103151555070"></p>
<p>上图是Windows子系统定义的图形体系结构。win32k.sys通过DDI（显示设备驱动程序接口）与现实驱动程序打交道，而显示驱动程序通过ENG（图形引擎接口）调用Win32k.sys中图形引擎的功能。</p>
<p>视频端口驱动程序实际上是一个动态链接库，用于辅助视频小端口驱动程序实现一些公共的、与图形有关的功能，以及为小端口驱动程序提供一个与系统内核和执行体打交道的环境。视频小端口驱动程序则直接负责的硬件资源管理和控制。</p>
<h3 id="系统线程和系统进程"><a href="#系统线程和系统进程" class="headerlink" title="系统线程和系统进程"></a>系统线程和系统进程</h3><p><strong>系统线程</strong>则是一些特殊线程，与普通用户线程不同，系统线程不属于任何特定的用户进程，它直接运行在内核模式下。</p>
<p>一些常见的系统线程：</p>
<ul>
<li><strong>Idle线程</strong>：它的任务是在系统没有其他任务要执行时，占用CPU周期并降低CPU功耗，它通常属于最低优先级，以确保在需要时可以立即释放CPU资源给其他任务。</li>
<li><strong>Deferred Procedure Call (DPC) 线程</strong>：DPC线程是用于处理延迟的硬件中断请求的系统线程。当硬件设备产生中断请求时，DPC线程负责处理这些请求并执行相应的处理程序。</li>
<li><strong>System线程</strong>：System线程执行一些关键的内核操作，如系统调度、中断处理、内存管理等。它是操作系统的核心部分，用于协调和管理其他系统线程和用户进程。</li>
</ul>
<p>系统线程中还有一组<strong>系统辅助线程（system worker thred）</strong>，它们代表操作系统或者其他的应用进程来完成一些特殊的工作。实际上，系统辅助线程是一个<strong>线程池</strong>，Windows在系统初始化时创建了一定数量的辅助线程，而且随着辅助线程的负载的变化，执行体也会动态地创建一些辅助线程，以满足系统负载的变化需求。</p>
<p>在Windows操作系统中，有一些重要的<strong>系统进程</strong>，它们负责管理和控制操作系统的不同方面。</p>
<p>一些常见的系统进程：</p>
<ul>
<li><strong>系统空闲进程（Idle）</strong>：该进程的PID为0，其中每个处理器或核对应有一个线程。</li>
<li><strong>System 进程</strong>：这是操作系统的好恶心进程，PID为4。它负责管理内核模式下线程、设备驱动程序、中断处理和其他核心人物。</li>
<li><strong>会话管理器（smss.exe）</strong>：Windows系统中创建的第一个用户模式进程，在Windows启动过程中创建环境变量，（启动了子系统进程csrss.exe和登录进程winlogon.exe）。另外，它还负责创建新的终端服务器会话，包括建立会话空间的数据结构，为新建的终端服务器加载子系统。</li>
<li><strong>登录进程（winlogon.exe）</strong>：负责处理交互用户的登录和注销。</li>
<li><strong>Windows子系统进程（csrss.exe）</strong>：负责为用户提供一个子系统环境。</li>
<li><strong>本地安全权威子系统进程（lsass.exe）</strong>：负责本地系统安全策略。</li>
<li><strong>Shell进程（explorer.exe）</strong>：Windows的默认Shell，它提供了系统与用户打交道的各种界面，包括开始菜单、任务栏、资源管理窗口等几乎所有Windows用户都熟悉的界面。</li>
<li><strong>服务控制管理器（services.exe）</strong>：负责Windows的系统服务，指一些特殊的进程。</li>
</ul>
<h2 id="内核基本概念"><a href="#内核基本概念" class="headerlink" title="内核基本概念"></a>内核基本概念</h2><p>Windows内核中的各个组件并非单纯的独立模块，相反地，组件之间不可避免地包含了复杂的依赖关系，甚至存在交叉引用。下面是一些Windows内核中的基本概念。</p>
<h3 id="处理器模式"><a href="#处理器模式" class="headerlink" title="处理器模式"></a>处理器模式</h3><p>在Intel x86处理器上，<strong>段描述符</strong>有一个2位长度的特权级：0表示最高特权级，3表示最低特权级。也就是CPU的权限级别0环和3环，分别对应内核模式和用户模式。</p>
<p>处理器有许多指令只有在<strong>零</strong>环内才可以使用，例如I&#x2F;O指令、操纵内部寄存器指令等，当处理器处于用户模式时，它处于一种相对隔离的状态：<strong>能够执行的指令有限，能够访问的内存也是有限的</strong>（用户代码和内核代码有各自的运行环境）。一旦越过这些限制，就会引发<strong>处理器异常</strong>，此时操作系统会捕获这些异常，并决定处理器是否继续执行。</p>
<p>用户模式下，处理器<strong>只能</strong>访问用户地址空间，而在内核模式下，处理器<strong>不仅</strong>可以访问用户地址空间，<strong>也</strong>可以访问系统地址空间。在内核模式下的代码和数据都是<strong>共享</strong>的，所有的进程一旦其指令流进入到内核模式下，则系统地址空间的代码和护具都是相同的。</p>
<p>一个指令流（即线程）在执行时，在以下情况会发生模式切换：</p>
<ul>
<li>用户模式代码<strong>触发了异常</strong>，则控制流进入到内核模式，内核中的异常处理函数可以决定该控制流是否继续执行。</li>
<li>用户模式代码执行时，被一个<strong>中断</strong>打断，控制流进入特权模式，等中断处理例程完成后，它若调用<code>iret/iretd</code>指令，则控制流恢复到用户模式下。</li>
<li>执行特殊的<strong>模式切换指令</strong>，如Intel x86的<code>sysenter</code>指令，从用户模式切换到内核模式。若想从内核模式切换到用户模式1，通常使用<code>sysexit</code>、<code>iret/iretd</code>这样的指令。</li>
</ul>
<p>由于系统空间是所有进程共享的，所以，任何一个进程在执行内核模式的代码时，实际上是在使用操作系统的服务。在Windows体系结构中，内核模式向上优一个执行体API，对于应用程序而言，这便是系统服务。</p>
<p>Windows将这些系统服务组织成了一张表，称为<strong>SDT（Service Descriptor Table，服务描述符表）</strong>。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>任何一个进程都定义了它自己完整的4GB地址空间（虚拟内存空间），在内存空间分布一图中，将其划分成2GB内核空间以及2GB应用空间，换句话说，内核空间是所有进程共享的，也称作<strong>系统地址空间</strong>，剩下的2GB空间才是它自己私有的，也叫<strong>进程地址空间</strong>。</p>
<p>为了有效管理2GB的系统地址空间，Windows将2GB划分成了一些固定的区域，主要包括：内核模块映像、PFN数据库、换页内存池、非换页内存池、会话空间、系统缓存区、系统视图以及页表等。</p>
<p><strong>分页机制</strong>：</p>
<p>Windows使用<strong>分页机制</strong>管理虚拟内存和物理内存。它将虚拟内存和物理内存划分成固定大小的页面，通过映射这些页面来实现虚拟地址到物理地址的转换。</p>
<p>通常操作系统将内存划分为<strong>大小固定的页面</strong>，通常为 <strong>4KB</strong>、8KB 或其他大小。这些页面是虚拟内存和物理内存的<strong>基本单位</strong>；之后操作系统将进程的虚拟地址空间也划分成页面大小的块。当程序访问进程的虚拟地址时，操作系统将虚拟地址转化成相应的物理地址。</p>
<p>为了实现虚拟地址到物理地址的转换，需要使用到<strong>页面表</strong>。</p>
<ul>
<li><strong>页面表</strong> 是操作系统中的一个数据结构，用于记录虚拟地址空间中每个页面与实际物理内存中的对应关系。页面表的条目存储了虚拟页号到物理页号的映射关系。</li>
<li>页面表中的每个条目称为<strong>页表项（Page Table Entry，PTE</strong>）。每个 PTE 存储了虚拟页号到物理页号的映射，以及一些额外的控制信息，例如页面是否在物理内存中、是否被修改等。</li>
</ul>
<p>当程序访问进程的虚拟地址时，<strong>MMU</strong>负责将这个虚拟地址通过页面表转化成物理地址。</p>
<p>如果虚拟页已经在物理内存中，则直接获取物理地址。如果虚拟页不在物理内存中，就需要进行<strong>页面调度</strong>。</p>
<p><strong>页面调度</strong>：</p>
<ul>
<li><p>如果虚拟页不在物理内存中，会先引发一个 <strong>缺页异常</strong>。这时，操作系统需要根据页表中的信息确定要将哪一页加载到物理内存中。</p>
</li>
<li><p>然后操作系统会将当前没用的物理页写入磁盘中，将需要的虚拟页加载入物理页。</p>
</li>
</ul>
<p><strong>从内存中获取数据的过程</strong>：</p>
<ul>
<li>程序访问进程的虚拟地址</li>
<li>MMU在通过页面表查询虚拟地址对应的虚拟页是否在物理内存中</li>
<li>若在，直接获取物理地址，返回数据；</li>
<li>若不在，引发缺页异常，MMU在页面表中查找对应的虚拟页，通过页面调度将虚拟页加载到物理内存中</li>
<li>获取物理地址，返回数据。</li>
</ul>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031733063.png" srcset="/img/loading.gif" lazyload alt="image-20231213214736149"></p>
<p>​	<strong>至于数据在物理内存中还是虚拟内存中是没有规律的，取决于数据使用的频繁程度。</strong></p>
<p><strong>内存页面管理算法</strong></p>
<p>在系统地址空间中，不同的区域使用并不完全相同的内存页面管理算法，较为典型的有以下三种：</p>
<ul>
<li><strong>非换页内存池</strong>：这部分内存区域在初始化时就已经被映射到物理页面，所以Windows利用空闲链表的做法，按照不同的粒度（1、2、3、&gt;&#x3D;4个页面大小），将空闲页面链接起来。空闲页面本身即链表中的节点，因而这些链表无需额外的内存空间（除了头节点）。申请和释放页面的操作实际上是针对空闲链表来进行的。</li>
<li><strong>换页内存池</strong>：在换页内存池区域，空闲的页面并没有被映射好物理页面，Windows使用位图来管理页面的分配。分配连续的多个页面，即从位图中找到连续的零位。</li>
<li><strong>系统PTE区域</strong>：这部分内存区域存放的并非PTE，而只是表示这部分地址范围是以PTE的形式来管理的，即把PTE当做资源来管理。当内核需要一段虚拟地址来映射物理页面时，它可以使用系统PTE区域中的地址。</li>
</ul>
<p>以上这些内存区域按照<strong>页面粒度</strong>来管理其分配情况，Windows执行体在这些系统内存区域管理的基础上，还提供了一组更小的粒度（8B的倍数，最小位8B）的内存管理，包括<strong>执行体换页内存池</strong>和<strong>执行体非换页内存池</strong>。这些内存池通过<strong>空闲链表</strong>记录下每个已申请页面中的空闲内存块；当释放内存时，自动与相邻的空闲块合并以构成更大的空闲内存块。内核其他组件或驱动程序通过执行体暴露的API函数（例如<code>ExAllocatePoolWithTag</code>和<code>ExFreePoolWithtag</code>）来使用这些内存池。</p>
<p>进程地址空间是随进程一起被创建的，每个进程都有它自己的页目录页面，其中有一半的<strong>页目录项（PDE）</strong>是共享的，即系统地址空间部分，余下一半初始化为零。随着进程中的映像文件（包括.exe文件和各DLL文件）被加载进来，以及各个模块的初始化代码被执行，进程地址空间将被建立起来。</p>
<p>进程地址空间按照其<strong>虚拟地址是否被分配或保留</strong>来进行管理，用户模式代码通过Windows API函数 <code>VirtualAlloc</code> 和 <code>VirtualFree</code>来申请或释放地址范围，而内核中的虚拟内存管理器则通过一颗<strong>平衡二叉树</strong>来管理进程地址空间被使用的情况。数中的每个节点为<strong>VAD（虚拟地址描述符，Virtual Address Descriptor）</strong>，描述了一段连续的地址方位。</p>
<p>在VAD树中，有一种重要的节点类型为<strong>内存区对象（section object）</strong>，它是Windows平台上俩个或多个进程之间共享内存的一种方式。</p>
<p>除了对系统地址空间和进程地址空间的管理，内存管理器另一个重要的任务是<strong>管理有限的物理内存</strong>。在WIndows的系统地址空间中，专门保留了一个称为<strong>PFN数据库（Page Frame Number Database，页帧编号数据库）</strong>的区域。</p>
<p>当系统中的进程需要使用大量内存时，内存管理其如何将有限的物理页面分配给那些需要使用内存的进程？利用Windows工作集管理器。<strong>工作集（working set）</strong>是指<strong>一个进程当前正在使用的物理页面的集合</strong>。Windows系统中除了<strong>进程工作集</strong>，还有<strong>系统工作集</strong>（即系统空间中动态映射的页面集合）和<strong>会话工作集</strong>（即会话空间中的代码和数据区）。</p>
<p>工作集管理器运行在一个称为<strong>平衡管理器（balance set manager）</strong>的<strong>线程</strong>中，它的作用除了<strong>触发工作集管理器</strong>，还定期<strong>触发进程&#x2F;栈交换器（process&#x2F;stack swapper）</strong>。进程&#x2F;栈交换是另一个单独的<strong>线程</strong>，一旦被唤醒，就会将满足特定条件的进程和栈换入内存或换出内存。</p>
<h3 id="进程和线程管理"><a href="#进程和线程管理" class="headerlink" title="进程和线程管理"></a>进程和线程管理</h3><p><strong>进程（process）</strong>定义了一个执行环境，包括它自己的私有空间、一个句柄表、以及一个安全环境；<strong>线程（thread）</strong>是一个控制流，有自己的<strong>调用栈（call stack）</strong>，记录它的执行历史。</p>
<p>一个进程包含一个或多个线程。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401031958530.png" srcset="/img/loading.gif" lazyload alt="image-20240103195851417"></p>
<p>如图，用户模式下的进程只能访问进程地址空间，若在内核模式下，就可以访问真个地址空间。</p>
<p>在Windows内核结构中，进程和线程的核心机制是在微内核中实现的，而管理机制是在执行体中实现的。例如，微内核负责线程调度，而线程进程的创建和初始化由执行体完成。</p>
<p>windows实现了<strong>抢占式线程调度</strong>，每个线程都有一个基本优先级和动态优先级。本质上每个线程都处于俩种状态之一：满足继续执行的条件，正在排队或已经执行；不满足继续执行的条件，处于等待状态，或者它的调用栈升职所处的进程已经被换出内存。在前一种情况下，线程按照优先级排队执行；对于多处理器系统，排队过程要更为复杂，不仅要处理多个队列，还要考虑每个处理器的就绪线程队列的平衡程度。还需要考虑处理器亲和性。</p>
<p>关于作业和迁程，<strong>作业（job）</strong>是一个执行体支持的内核对象，它使得一个或多个进程被当做一个整体来加以管理和控制。管理程序通过Windows API 可以控制一个作业小号系统资源（CPU或内存）的各种限制，例如用户模式CPU时间的限制、进程的处理器亲和性、工作集的最大值和最小值、虚拟内存的使用限制等。<strong>迁程（fiber）</strong>是一种用户线程，它对于内核是不可见的，由kernel32.dll实现。应用程序可以在一个线程环境中创建多个迁程，然后手动控制它们的执行。迁程不会被自动执行，应用程序必须显式地选择某个迁程来执行，而且一旦迁程运行起来，要么一直运行到它退出，要么运行到它显式地切换至另一个迁程。</p>
<h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p><strong>中断（interrupt）</strong>是指处理器外部事件（如硬件设备）触发的信号，它会中断当前的处理器活动。<strong>异常（Exceptions）</strong>指程序执行过程中出现的非正常或意外情况，由处理器内部事件（如执行了错误指令）触发。</p>
<p>尽管中断和异常的触发来源和方式不同，但Intel x86处理器内部使用<strong>同一套陷阱机制</strong>来处理中断和异常，它利用<strong>IDT（Interrupt Descriptor Table，中断描述符表）</strong>，将每个中断或异常与一个处理该中断或异常的服务例程联系起来，因而一旦发生异常或中断，该相应的服务例程将被执行。Windows在此基础上，添加了一种更灵活的机制，允许设备驱动程序为特定的<strong>中断向量</strong>添加它的<strong>中断服务例程（ISR，Interrupt Service Routine）</strong>。一个中断向量允许连接多个<strong>中断对象（interrupt object）</strong>，这里中断对象是一种封装了中断服务例程的<strong>内核对象</strong>。当中断发生时，这些中断对象中的服务例程都有机会处理该中断。通过中断对象机制，设备驱动程序可以在不操纵IDT的情况下加入它们的中断服务例程；另一方面，多个硬件设备也可以共享同样的硬件中断向量。</p>
<p>执行体层中介绍过<strong>中断请求级别IRQL</strong>。</p>
<p>异常是程序指令流执行过程中的<strong>同步处理过程</strong>，既可以由<strong>处理器硬件</strong>产生，也可以由<strong>指令流软件</strong>产生。Windows为所有需要处理的异常都提供了<strong>异常处理器（exception handler，即异常处理例程）</strong>。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>在现代操作系统中，由于多处理器、多核或者中断各种<strong>并发性（concurrency）</strong>因素的存在，同样的代码可能被并发执行，而数据也可能被并发访问。在这种情况下，对于可能被并发访问的数据进行必要的<strong>同步（synchronization）保护</strong>是一种常见的编程实践。</p>
<p>一些同步中会遇到的概念：</p>
<ul>
<li>关于<strong>锁</strong>。什么是锁？锁是一种同步机制，用于确保在同一时刻只有<strong>一个线程</strong>能够访问共享资源；也就是保护<strong>临界区</strong>，确保在任何时刻只有<strong>一个线程</strong>可以进入临界区执行操作。锁包括<strong>互斥锁</strong>、<strong>自旋锁</strong>、<strong>读写锁</strong>等不同类型。</li>
<li><strong>临界区</strong>。什么临界区？临界区是用于保护共享资源免受多个线程同时访问的一种同步机制：当一个线程进入临界区时，其他线程必须等待，直到第一个线程离开临界区。常用于用户模式下。</li>
</ul>
<p>Windows根据执行环境中的<strong>IRQL大于APC_LEVEL 或者等于PASSIVE_LEVEL</strong>，将同步机制分为“<strong>不依赖线程调度的同步机制</strong>”和“<strong>基于线程调度的同步机制</strong>”。</p>
<p>不依赖线程调度的同步机制主要是在<strong>IRQL的高优先级</strong>下执行的，通常用于中断处理程序和内核模式代码中，以确保在处理中断或执行关键内核代码时，不会被其他线程打断。常见的不依赖线程调度的同步机制包括：</p>
<ul>
<li><strong>自旋锁（Spin Lock）</strong>：自旋锁用于在多个线程之间互斥的访问共享资源，本质上是一种<strong>忙等待（busy-wait）</strong>，意思是线程会<strong>一直自旋（忙等待）直到锁可用为止，而不会被挂起等待。</strong>常使用在高IRQL下，因为此时是不允许切换线程的，使用自旋锁可以确保关键代码不会被其他线程打断。一些<strong>自旋锁扩展</strong>：执行体自旋锁（支持共享和独占的语义）、排队自旋锁（queued spin lock）和栈内排队自旋锁（in-stack queued spin lock）。</li>
<li><strong>中断服务例程（ISR）</strong>：ISR用于响应硬件中断，当硬件设备触发中断时，操作系统会立即执行ISR来处理中断。ISR运行在IRQL的高优先级下，不允许进行线程调度，以确保快速响应中断。</li>
<li><strong>延迟过程调用（Deferred Procedure Call，DPC）</strong>：DPC用于延迟执行一些代码块或处理程序，常与中断处理有关。当硬件设备触发中断时，操作系统会将<strong>中断服务例程（ISR）</strong>用于快速响应中断，但有时需要执行一些耗时的操作，例如数据传输或资源释放，这时就会使用DPC来延迟执行这些操作。</li>
</ul>
<p>另一种基于线程调度的同步机制：当一个线程的<strong>执行条件</strong>不满足时，该线程进入等待状态，系统将控制权交由其他满足<strong>执行条件</strong>但没有得到处理器资源的线程；以后，当该线程的<strong>执行条件</strong>满足时，它又有机会继续执行。这里的执行条件正是Windows提供的线程同步机制中的<strong>语义</strong>。Windows定义了统一的机制来支持各种线程同步原语：<strong>分发器对象（dispatcher object）</strong>，其数据结构头部为<strong>DISAPATCH_HEADER</strong>。</p>
<p>常见的分发器对象：</p>
<ul>
<li><strong>事件（event）</strong>：用于线程之间的通信和同步，它有俩种状态：已触发和未触发。事件可以用于线程等待某个事件发生，或者通知其他线程事件的发生。</li>
<li><strong>互斥量（Mutex）</strong>：互斥量用于确保在同一时刻只有一个线程能够访问共享资源。它允许线程请求锁定，当一个线程获得锁定时，其他线程必须等待，直到锁被释放。</li>
<li><strong>信号量（Semaphore）</strong>：用于控制对共享资源的并发访问。它维护一个计数器，允许指定数量的线程同时访问资源。</li>
<li><strong>条件变量（Condition Variable）</strong>：条件变量用于线程之间传递信号和等待特定条件的发生。通常与互斥量一起使用，用于等待某个条件满足后执行操作。</li>
<li><strong>读写锁（Read-Write Locks）</strong>：读写锁用于控制对共享资源的读和写，它允许多个线程同时读取资源，但只允许一个线程写入资源。</li>
<li><strong>计数器对象（Counting Semaphore）</strong>：一种特殊的信号量，它可以增加和减少计数器的值，通常用于跟踪资源的可用性或完成的任务数量。</li>
</ul>
<p><strong>互斥锁（Mutex）</strong>是一种基于线程调度的同步机制，它用于确保在同一时刻只有一个线程能够访问共享资源。当一个线程获得互斥锁的所有权后，其他线程必须等待，直到该线程释放锁。</p>
<p>关于互斥锁和自旋锁：互斥锁基于线程调度，而自旋锁不依赖线程调度；还有一个区别是线程尝试获取锁时，如果该锁被占用，线程是被挂起还是一直自旋；互斥锁适用于长时间的临界区和资源竞争激烈的情况，而自旋锁适用于非常短暂的临界区。</p>
<p>Windows在上述基础上，实现了同步语义更为丰富的一些同步机制，包括：<strong>快速互斥体（fast mutex）</strong>、<strong>守护互斥体（guarded mutex）</strong>、<strong>执行体资源（executive resource）</strong>和<strong>推锁（push lock）</strong>。</p>
<h2 id="内核重要数据结构"><a href="#内核重要数据结构" class="headerlink" title="内核重要数据结构"></a>内核重要数据结构</h2><p>windows内核中一些常见的数据结构。</p>
<h3 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h3><p>内核对象是Windows内核中一种重要的<strong>数据结构管理机制</strong>。应用层的进程、线程、文件、驱动模块、事件、信号量等对象或者打开的句柄在内核中都有与之对应的内核对象。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040002657.png" srcset="/img/loading.gif" lazyload alt="image-20240104000229599"></p>
<p>如图，一个Windows内核对象可以分为<strong>对象头</strong>和<strong>对象体</strong>俩部分。在对象头中至少有一个<strong>OBJECT_HEADER</strong>和<strong>对象额外信息</strong>。对象体紧接着对象头中的OBJECT_HEADER。一个对象指针总是<strong>指向对象体</strong>而不是对象头。如果要访问对象头，需要将对象体指针<strong>减去</strong>一个特定的偏移值，以获取OBJECT_HEADER结构，通过OBJECT_HEADER结构定位从而访问其他对象结构辅助。对象体内部一般会有<strong>1个type</strong>和<strong>1个size</strong>成员，用来表示<strong>对象的类型和大小</strong>。</p>
<p>Windows内核对象可以分为如下3种类型：</p>
<ol>
<li><p><strong>Dispatcher对象</strong></p>
<p>这种对象在对象体开始位置了一个<strong>公共数据结构DISPATCHER_HEADER</strong>，其结构代码如下：</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040028701.png" srcset="/img/loading.gif" lazyload alt="image-20240104002800628"></p>
<p>包含了<code>DISPATCHER_HEADER</code>结构的内核对象都以<strong>字母“K”开头</strong>，表明这是一个内核对象，例如KPROCESS、KTHREAD，但以字母“K”开头的内核对象不一定是Dispatcher对象。包含该结构的内核对象都是<strong>可以等待的（waitable）</strong>，也就是说，这些内核对象可以作为参数传给内核的<code>KewaitForSingleObject()</code>和<code>KeWaitForMultipleObjects()</code>函数，以及应用层的<code>WaitForSingleObject()</code>和<code>WaitForMultipleObject()</code>函数。</p>
</li>
<li><p><strong>I&#x2F;O对象</strong></p>
<p>I&#x2F;O对象在对象体开始位置没有DISPATCHER_HEADER结构，但通常会放置一个与type和size有关的整型成员，以表示该内核对象的<strong>类型</strong>（例如文件内核对象的类型为26）和<strong>大小</strong>。常见的I&#x2F;O对象包括DEVICE_OBJECT、DRIVER_OBJECT、FILE_OBJECT等。</p>
</li>
<li><p><strong>其他对象</strong></p>
<p>除了Dispatcher对象和I&#x2F;O对象，剩下的都属于<strong>其他内核对象</strong>。其中有俩个常用的内核对象，分别是<strong>进程对象（EPROCESS）</strong>和<strong>线程对象（ETHREAD）</strong>。</p>
<p>EPROCESS用于在内核中管理进程的各种信息，如<strong>进程ID、进程状态、内存管理信息</strong>等。所有进程的EPROCESS内核结构都被放入一个<strong>双向链表</strong>，R3在枚举系统进程的时候，通过遍历这个链表获得了进程的列表。因此有的Rookit会试图将自己进程的EPROCESS结构从这个链表摘掉，从而达到隐藏自己的目的。</p>
<p><strong>EPROCESS结构</strong>中的一些关键数据如下：</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040040028.png" srcset="/img/loading.gif" lazyload alt="image-20240104004007952"></p>
<p>调用下面俩个内核函数可以获得进程的EPROCESS结果。</p>
<p><code>PsLookupProcessByProcessId()</code>函数，根据<strong>进程PID</strong>拿到进程的EPROCESS结构；<code>PsGetGurrentProcess()</code>函数，<strong>直接</strong>获取当前进程的EPROCESS结构。</p>
<p><strong>ETHREAD结构</strong>是线程的内核管理对象。它代表Windows中的一个线程，<strong>包含了线程的执行上下文、调度信息。</strong></p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040046513.png" srcset="/img/loading.gif" lazyload alt="image-20240104004659468"></p>
<p>EPROCESS、KPROCESS、ETHREAD、KTHREAD结构之间的关系如下图。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401040047536.png" srcset="/img/loading.gif" lazyload alt="image-20240104004747444"></p>
<p>可以看出，EPROCESS和ETHREAD结构都是通过<strong>双向循环链表</strong>组织管理的。一个EPROCESS结构中包含一个KPROCESS结构，而在一个KPROCESS结构中又有一个指向ETHREAD结构的指针。在ETHREAD结构中，又包含了KTHREAD结构成员。</p>
</li>
</ol>
<p>	</p>
<h3 id="SSDT"><a href="#SSDT" class="headerlink" title="SSDT"></a>SSDT</h3><p><strong>系统服务描述表（System Services Descriptor Table，SSDT）</strong>其在内核中的实际名称是 “<strong>KeServiceDescriptorTable</strong>”。</p>
<p>它用于<strong>处理应用层通过kernel32.dll下发的各个API操作请求</strong>。ntdll.dll中的API是一个简单的包装函数，当kernel32.dll中的API通过ntdll.dll时，会先完成对参数的<strong>检查</strong>，再调用一个<strong>中断</strong>（<code>int 2Eh</code>或者<code>SysEnter</code>指令），从而实现从R3层进入R0层，并将要调用的服务号（也就是SSDT数组中的<strong>索引号</strong>index值）存放到寄存器EAX中，最后根据存在EAX中的索引值在SSDT数组中调用指定的<strong>服务</strong>（Nt*系列函数）。如下图：</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401041606154.png" srcset="/img/loading.gif" lazyload alt="image-20240104160639068"></p>
<p>SSDT表的结构定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceDescriptorEntry</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *ServiceTableBase;		<span class="hljs-comment">//表的基地址</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *ServiceCounterTableBase;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> NumberOfServices;		<span class="hljs-comment">//表中服务的个数</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *ParamTableBase;<br>&#125; ServiceDescriptorTableEntry_t,<br>*PServiceDescriptorTableEntry_t;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br></code></pre></td></tr></table></figure>

<p>其中较为重要的俩个成员为<code>ServiceTableBase</code>（SSDT表的基地址）和<code>NumberOfServices</code>（表示系统中SSDT服务函数的个数）。<strong>SSDT表实际上是一个连续存放该函数指针的数组</strong>。</p>
<p>SSDT表的导入方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__declspec(dllimport) ServiceDescriptorTableEntry_t KeServiceDescriptorTable;<br></code></pre></td></tr></table></figure>

<p>由此可以知道SSDT表的基地址和SSDT函数的索引号（index），从而求出对应的服务函数地址。在x86平台上，它们之间满足如下规则：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">FuncAddr</span> = <span class="hljs-title class_">KeServiceDescriptorTable</span> + <span class="hljs-number">4</span> * index<br></code></pre></td></tr></table></figure>

<p>与x86平台上直接在SSDT中存放SSDT函数地址不同，在x64平台上，SSDT中存放的是索引号锁对象的SSDT函数地址和SSDT表基地址的偏移量左移4位的值，因而计算公式变为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">FuncAddr</span> = ([<span class="hljs-title class_">KeServiceDescriptorTable</span> + index * <span class="hljs-number">4</span>] &gt;&gt; <span class="hljs-number">4</span> + <span class="hljs-title class_">KeServiceDescriptorTable</span>)<br></code></pre></td></tr></table></figure>

<p>通过这个公式，只要知道SSDT表的基地址和对应函数的索引号，就可以将对应位置的服务函数替换成自己的函数，从而完成SSDT Hook过程了。</p>
<h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p>操作系统会为每个进程设置一个数据结构，用来记录进程的相关信息。该结构就是<strong>PEB（Process Environment Block，进程环境块）</strong>，PEB存在于用户地址空间中，记录了进程的相关信息。</p>
<p>在NT中，PEB位于进程空间的<code>FS:[0x30]</code>处。同时，TEB中的 <code>ProcessEnvironmentBlock</code> 就是PEB结构的地址，其结构的0x30偏移处是一个指向PEB的指针。</p>
<p>因此，访问PEB有俩种方法：</p>
<ol>
<li><p>直接获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax, dword ptr fs:[30h]   ; fs:[30]里存放即是PEB地址<br></code></pre></td></tr></table></figure>
</li>
<li><p>通过TEB获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax, dword ptr fs:[18h]     ;此时eax里为TEB的指针<br>mov eax, dword ptr [eax+30h]	;此时eax里为PEB的指针<br></code></pre></td></tr></table></figure></li>
</ol>
<p>PEB结构（部分）：<br><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401041650999.png" srcset="/img/loading.gif" lazyload alt="image-20231226195733857"></p>
<p>其中，<code>BeingDebugged</code>成员用于指定该进程是否处于被调试状态，该值为0时进程未处于调试状态，若该值为非零值，则进程处于调试状态。（可以使用Windows API，如<code>IsDebuggerPresent</code>、<code>CheckRemoteDebuggerPresent</code>函数来访问该成员）</p>
<p><strong>Ldr</strong>字段也是一个很重要的成员，该字段指向的结构记录了进程加载进内存的所有模块的基地址，通过Ldr指向的三个链表就可以找到<code>kernel32.dll</code>的基地址。</p>
<h3 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h3><p><strong>TEB（Thread Environment Block，线程环境块）</strong>同样位于应用层之中。它包含了系统频繁使用的一些与线程相关的数据，进程中的每个线程都有一个自己的TEB。一个进程的所有TEB都存放在从0x7FFDE000开始的线性内存中，每4KB为一个完整的TEB。</p>
<p>在NT中，<code>FS:[0]</code>的地址指向了TEB结构，这个结构的开头是一个<strong>NT_TIB</strong>结构，具体（部分）如下：</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312262012839.png" srcset="/img/loading.gif" lazyload alt="image-20231226201240784"></p>
<p>NT_TIB结构的<strong>0x18</strong>偏移处是一个<strong>Self指针</strong>，指向这个结构自身，也就是TEB结构的开头。TEB结构的<strong>0x30</strong>偏移处是一个指向PEB的指针。</p>
<p>在TEB结构的<strong>0xE10</strong>偏移处有个字段<code>TlsSlots[]</code>，是一个无类型的指针数组（TLS存储槽），它的大小是40h字节。也就是说，一个线程同时存在的动态TLS不能超过64项。</p>
<p>可以通过NtCurrentTeb函数调用和FS段寄存器俩种方法来访问TEB结构：</p>
<ol>
<li><p>NtCurrentTeb函数调用</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202312262020779.png" srcset="/img/loading.gif" lazyload alt="image-20231226202035720"></p>
</li>
<li><p>FS段寄存器访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax, dword ptr fs:[18h]  <br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h3><p>Windows注册表也可以被视为一种<strong>特殊</strong>的数据结构，它是一个<strong>层次结构数据库</strong>，用于存储和组织系统配置信息、应用程序设置和其他系统相关的数据。</p>
<p>Windows提供了一些API供应用程序访问注册表，例如<code>RegOpenKeyEx</code>、<code>RegCreateKeyEx</code>等。这些API运行开发人员在应用程序中读取、写入、编辑和删除注册表中的键值和数据。</p>
<p>在Win10中通过Win+R输入regedit即可查看注册表。</p>
<p><img src="https://gitee.com/Sciurdae/typora-images/raw/master/img/202401041702378.png" srcset="/img/loading.gif" lazyload alt="image-20240104170258314"></p>
<p>如上图，Windows注册表是一个树状（层次）结构：</p>
<ol>
<li>每个节点是一个键（key）或值（value）。</li>
<li>键是一个容器，好比文件系统中的目录，它可以包含其他的键（子键）和值。注册表中的每个键都有一个唯一的名称，用于标识它。</li>
<li>值存储的是数据，好比是文件系统中的文件。数据可以是字符串、整数、二进制数据等不同的类型。</li>
<li>注册表的根也是一个键，称为根键。一般为5个根键，常见的根键包括HKEY_LOCAL_MACHINE（存储计算机范围的配置信息）、HKEY_CURRENT_USER（存储当前用户的配置信息）等。</li>
</ol>
<p>在内核之中，执行体包含了一个称为“<strong>配置管理器</strong>”的组件，它是注册表的真正实现。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Windosw内核理论基础</div>
      <div>http://sciurdae.online/2024/04/02/Windows内核基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Sciurdae</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/04/02/Windows%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/" title="Windows反调试技术">
                        <span class="hidden-mobile">Windows反调试技术</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div style="font-size: 1rem"> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </div> <div style="font-size: 1rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        <span style='font-size: 1.1rem'>总访问量 
        <span id="leancloud-site-pv"></span>
         次</span>
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        <span style='font-size: 1.1rem'>总访客数 
        <span id="leancloud-site-uv"></span>
         人</span>
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/decorate.js"></script>
<script src="/js/customm.js"></script>
<script src="/js/scrollAnimation.js"></script>
<script src="/js/codeType.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script><!-- hexo injector body_end end --></body>
</html>
